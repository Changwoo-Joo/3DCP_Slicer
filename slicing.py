import streamlit as st
import numpy as np
import trimesh
import tempfile
import plotly.graph_objects as go
from typing import List, Tuple, Optional, Dict, Any
import json
import os
from datetime import datetime, timedelta, date

# =========================
# App basics
# =========================
st.set_page_config(page_title="3DCP Slicer", layout="wide")
APP_TITLE = "3DCP Slicer"

# ---- Admin password (변경하세요) ----
ADMIN_PASSWORD = "darobotics-admin*"

# ---- Auth data file (persistent) ----
AUTH_DB_PATH = "/mnt/data/3dcp_auth.json"

# ---- Path color for paths (단색) ----
EXTRUSION_K = 0.05
PATH_COLOR = "#222222"

# =========================
# Auth Utilities
# =========================
def load_auth_db() -> Dict[str, Any]:
    if os.path.exists(AUTH_DB_PATH):
        try:
            with open(AUTH_DB_PATH, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            pass
    # default structure
    return {
        "accounts": [
            # sample:
            # {"label":"demo7d","password":"darobotics*","expires_on":"2025-12-31"},
            # {"label":"permanent","password":"darobotics-perm*","expires_on":None},
        ],
        "updated_at": datetime.utcnow().isoformat()
    }

def save_auth_db(db: Dict[str, Any]) -> None:
    db["updated_at"] = datetime.utcnow().isoformat()
    with open(AUTH_DB_PATH, "w", encoding="utf-8") as f:
        json.dump(db, f, ensure_ascii=False, indent=2)

def find_account_by_password(db: Dict[str, Any], pwd: str) -> Optional[Dict[str, Any]]:
    for acc in db.get("accounts", []):
        if acc.get("password") == pwd:
            return acc
    return None

def days_remaining(expires_on: Optional[str]) -> Optional[int]:
    if not expires_on:
        return None
    try:
        d = datetime.strptime(expires_on, "%Y-%m-%d").date()
    except ValueError:
        return None
    today = date.today()
    return (d - today).days

def is_account_active(acc: Dict[str, Any]) -> bool:
    exp = acc.get("expires_on")
    if exp is None:
        return True
    left = days_remaining(exp)
    return left is not None and left >= 0

def upsert_account(db: Dict[str, Any], label: str, password: str, days: Optional[int]) -> None:
    # days=None -> 무기한, else -> 오늘 기준 days일 뒤 만료
    expires_on = None if days is None else (date.today() + timedelta(days=days)).strftime("%Y-%m-%d")
    found = None
    for acc in db.get("accounts", []):
        if acc.get("label") == label:
            found = acc
            break
    if found:
        found["password"] = password
        found["expires_on"] = expires_on
    else:
        db.setdefault("accounts", []).append({
            "label": label,
            "password": password,
            "expires_on": expires_on
        })
    save_auth_db(db)

def delete_account(db: Dict[str, Any], label: str) -> None:
    db["accounts"] = [a for a in db.get("accounts", []) if a.get("label") != label]
    save_auth_db(db)


# =========================
# Geometry helpers (원래 연산식 그대로)
# =========================
def trim_segment_end(segment, trim_distance=30.0):
    segment = np.array(segment)
    total_len = np.sum(np.linalg.norm(np.diff(segment, axis=0), axis=1))
    if total_len <= trim_distance:
        return segment
    trimmed = [segment[0]]
    acc = 0.0
    for i in range(1, len(segment)):
        p1, p2 = segment[i - 1], segment[i]
        d = np.linalg.norm(p2 - p1)
        if acc + d >= total_len - trim_distance:
            r = (total_len - trim_distance - acc) / d
            trimmed.append(p1 + (p2 - p1) * r)
            break
        trimmed.append(p2)
        acc += d
    return np.array(trimmed)

def simplify_segment(segment, min_dist):
    simplified = [segment[0]]
    for pt in segment[1:-1]:
        if np.linalg.norm(pt[:2] - simplified[-1][:2]) >= min_dist:
            simplified.append(pt)
    simplified.append(segment[-1])
    return np.array(simplified)

def shift_to_nearest_start(segment, ref_point):
    idx = np.argmin(np.linalg.norm(segment[:, :2] - ref_point, axis=1))
    return np.concatenate([segment[idx:], segment[1:idx + 1]], axis=0), segment[idx]

# =========================
# G-code generator (원래 로직)
# =========================
def generate_gcode(mesh, z_int=30.0, feed=2000, ref_pt_user=(0.0, 0.0),
                   e_on=False, start_e_on=False, start_e_val=0.1, e0_on=False,
                   trim_dist=30.0, min_spacing=3.0, auto_start=False, m30_on=False):
    g = ["; *** Generated by 3DCP Slicer ***", "G21", "G90"]
    if e_on:
        g.append("M83")

    z_max = mesh.bounds[1, 2]
    z_values = list(np.arange(z_int, z_max + 0.001, z_int))
    if abs(z_max - z_values[-1]) > 1e-3:
        z_values.append(z_max)
    z_values.append(z_max + 0.01)

    prev_start_xy = None
    for z in z_values:
        sec = mesh.section(plane_origin=[0,0,z], plane_normal=[0,0,1])
        if sec is None:
            continue
        try:
            slice2D, to3D = sec.to_2D()
        except Exception:
            continue

        segments = []
        for seg in slice2D.discrete:
            seg = np.array(seg)
            seg3d = (to3D @ np.hstack([seg, np.zeros((len(seg),1)), np.ones((len(seg),1))]).T).T[:, :3]
            segments.append(seg3d)
        if not segments:
            continue

        g.append(f"\n; ---------- Z = {z:.2f} mm ----------")

        if auto_start and prev_start_xy is not None:
            dists = [np.linalg.norm(s[0][:2] - prev_start_xy) for s in segments]
            first_idx = int(np.argmin(dists))
            segments = segments[first_idx:] + segments[:first_idx]
            ref_pt_layer = prev_start_xy
        else:
            ref_pt_layer = np.array(ref_pt_user)

        for i_seg, seg3d in enumerate(segments):
            shifted, _  = shift_to_nearest_start(seg3d, ref_pt_layer)
            trimmed     = trim_segment_end(shifted, trim_dist)
            simplified  = simplify_segment(trimmed, min_spacing)
            start       = simplified[0]

            g.append(f"G01 F{feed}")
            if start_e_on:
                g.append(f"G01 X{start[0]:.3f} Y{start[1]:.3f} Z{z:.3f} E{start_e_val:.5f}")
            else:
                g.append(f"G01 X{start[0]:.3f} Y{start[1]:.3f} Z{z:.3f}")

            for p1, p2 in zip(simplified[:-1], simplified[1:]):
                dist = np.linalg.norm(p2[:2] - p1[:2])
                if e_on:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f} E{dist * EXTRUSION_K:.5f}")
                else:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f}")

            if e0_on:
                g.append("G01 E0")

            if i_seg == 0:
                prev_start_xy = start[:2]

    g.append(f"G01 F{feed}")
    if m30_on:
        g.append("M30")
    return "\n".join(g)

# =========================
# Slice path computation (미리보기용, 레이어 간 travel 포함)
# returns: List[(poly Nx3, e_vals or None, is_travel)]
# =========================
def compute_slice_paths_with_travel(
    mesh,
    z_int=30.0,
    ref_pt_user=(0.0, 0.0),
    trim_dist=30.0,
    min_spacing=3.0,
    auto_start=False,
    e_on=False
) -> List[Tuple[np.ndarray, Optional[np.ndarray], bool]]:
    z_max = mesh.bounds[1, 2]
    z_values = list(np.arange(z_int, z_max + 0.001, z_int))
    if abs(z_max - z_values[-1]) > 1e-3:
        z_values.append(z_max)
    z_values.append(z_max + 0.01)

    all_items: List[Tuple[np.ndarray, Optional[np.ndarray], bool]] = []
    prev_layer_last_end: Optional[np.ndarray] = None
    prev_start_xy = None

    for z in z_values:
        sec = mesh.section(plane_origin=[0,0,z], plane_normal=[0,0,1])
        if sec is None:
            continue
        try:
            slice2D, to3D = sec.to_2D()
        except Exception:
            continue

        segments = []
        for seg in slice2D.discrete:
            seg = np.array(seg)
            seg3d = (to3D @ np.hstack([seg, np.zeros((len(seg),1)), np.ones((len(seg),1))]).T).T[:, :3]
            segments.append(seg3d)
        if not segments:
            continue

        if auto_start and prev_start_xy is not None:
            dists = [np.linalg.norm(s[0][:2] - prev_start_xy) for s in segments]
            first_idx = int(np.argmin(dists))
            segments = segments[first_idx:] + segments[:first_idx]
            ref_pt_layer = prev_start_xy
        else:
            ref_pt_layer = np.array(ref_pt_user)

        layer_polys: List[np.ndarray] = []
        for i_seg, seg3d in enumerate(segments):
            shifted, _ = shift_to_nearest_start(seg3d, ref_pt_layer)
            trimmed    = trim_segment_end(shifted, trim_dist)
            simplified = simplify_segment(trimmed, min_spacing)
            layer_polys.append(simplified.copy())
            if i_seg == 0:
                prev_start_xy = simplified[0][:2]

        if not layer_polys:
            continue

        # 레이어 간 travel (점선)
        first_poly_start = layer_polys[0][0]
        if prev_layer_last_end is not None:
            travel = np.vstack([prev_layer_last_end, first_poly_start])
            all_items.append((travel, np.array([0.0, 0.0]) if e_on else None, True))

        # 레이어 내부(압출 O)
        for poly in layer_polys:
            if e_on:
                e_vals = [0.0]
                total = 0.0
                for p1, p2 in zip(poly[:-1], poly[1:]):
                    dist = np.linalg.norm(p2[:2] - p1[:2])
                    total += dist * EXTRUSION_K
                    e_vals.append(total)
                all_items.append((poly, np.array(e_vals), False))
            else:
                all_items.append((poly, None, False))

        prev_layer_last_end = layer_polys[-1][-1]

    return all_items

# =========================
# Plotly: STL & Paths
# =========================
def plot_trimesh(mesh: trimesh.Trimesh, height=820) -> go.Figure:
    v = mesh.vertices
    f = mesh.faces
    fig = go.Figure(data=[go.Mesh3d(
        x=v[:,0], y=v[:,1], z=v[:,2],
        i=f[:,0], j=f[:,1], k=f[:,2],
        color="#888888",
        opacity=0.6,
        flatshading=True
    )])
    fig.update_layout(scene=dict(aspectmode="data"),
                      height=height, margin=dict(l=0, r=0, t=10, b=0))
    return fig

def plot_paths(items: List[Tuple[np.ndarray, Optional[np.ndarray], bool]], e_on=False, height=820) -> go.Figure:
    fig = go.Figure()
    for poly, e_vals, is_travel in items:
        if e_on and e_vals is not None:
            # ΔE>0 = 실선(압출), ΔE=0 = 점선(이동)
            for (p1, p2, e1, e2) in zip(poly[:-1], poly[1:], e_vals[:-1], e_vals[1:]):
                dash_style = "solid" if (e2 - e1) > 1e-12 else "dot"
                width = 3 if dash_style == "solid" else 2
                fig.add_trace(go.Scatter3d(
                    x=[p1[0], p2[0]], y=[p1[1], p2[1]], z=[p1[2], p2[2]],
                    mode="lines",
                    line=dict(width=width, dash=dash_style, color=PATH_COLOR),
                    showlegend=False
                ))
        else:
            # e_on=False면 모두 단색 실선
            fig.add_trace(go.Scatter3d(
                x=poly[:,0], y=poly[:,1], z=poly[:,2],
                mode="lines", line=dict(width=3, color=PATH_COLOR),
                showlegend=False
            ))
    fig.update_layout(scene=dict(aspectmode="data"),
                      height=height, margin=dict(l=0, r=0, t=10, b=0))
    return fig

# =========================
# Session init
# =========================
if "authenticated" not in st.session_state:
    st.session_state.authenticated = False
if "auth_label" not in st.session_state:
    st.session_state.auth_label = None
if "days_left" not in st.session_state:
    st.session_state.days_left = None
if "mesh" not in st.session_state:
    st.session_state.mesh = None
if "paths_items" not in st.session_state:
    st.session_state.paths_items = None
if "gcode_text" not in st.session_state:
    st.session_state.gcode_text = None
if "admin_mode" not in st.session_state:
    st.session_state.admin_mode = False

# =========================
# Login Screen (메인 영역에서 먼저)
# =========================
def login_screen():
    st.title(APP_TITLE)
    st.subheader("Login")
    pwd = st.text_input("Access password", type="password", key="user_pw")
    col1, col2 = st.columns([1,1])
    with col1:
        login_clicked = st.button("Login")
    with col2:
        admin_try = st.button("Admin mode")

    if admin_try:
        st.session_state.admin_mode = True
        st.experimental_rerun()

    if login_clicked:
        db = load_auth_db()
        acc = find_account_by_password(db, pwd)
        if acc is None:
            st.error("Invalid password.")
            return

        if not is_account_active(acc):
            # 만료됨
            left = days_remaining(acc.get("expires_on"))
            st.error("This account is expired. Please ask admin to extend.")
            return

        # OK
        st.session_state.authenticated = True
        st.session_state.auth_label = acc.get("label")
        st.session_state.days_left = days_remaining(acc.get("expires_on"))
        st.experimental_rerun()

# =========================
# Admin Screen
# =========================
def admin_screen():
    st.title(APP_TITLE + " · Admin")
    admin_pw = st.text_input("Admin password", type="password", key="admin_pw")
    if not st.session_state.get("admin_ok"):
        if st.button("Enter Admin"):
            if admin_pw == ADMIN_PASSWORD:
                st.session_state.admin_ok = True
                st.experimental_rerun()
            else:
                st.error("Wrong admin password.")
        return

    st.success("Admin authenticated.")
    db = load_auth_db()

    st.markdown("### Existing accounts")
    if not db.get("accounts"):
        st.info("No accounts yet.")
    else:
        for acc in db["accounts"]:
            label = acc.get("label")
            exp = acc.get("expires_on")
            left = days_remaining(exp)
            status = "active" if is_account_active(acc) else "expired"
            st.write(f"- **{label}** | expires_on: `{exp}` | left: `{left if left is not None else '∞'}` day(s) | {status}")

    st.markdown("---")
    st.markdown("### Add / Update account")
    up_label = st.text_input("Label (unique)")
    up_password = st.text_input("Password")
    colA, colB = st.columns([2,1])
    with colA:
        days_mode = st.selectbox("Expiration type", ["기간 지정", "무기한"])
    with colB:
        days_val = st.number_input("Days (if 기간 지정)", min_value=1, value=7, step=1)
    if st.button("Save account"):
        if not up_label or not up_password:
            st.error("Label and Password are required.")
        else:
            if days_mode == "무기한":
                upsert_account(db, up_label, up_password, None)
                st.success(f"Saved. {up_label} (no expiry)")
            else:
                upsert_account(db, up_label, up_password, int(days_val))
                st.success(f"Saved. {up_label} ({int(days_val)} days)")
            st.experimental_rerun()

    st.markdown("---")
    st.markdown("### Extend / Delete account")
    labels = [a.get("label") for a in db.get("accounts", [])]
    if labels:
        sel = st.selectbox("Select account", labels)
        colE, colF = st.columns([2,1])
        with colE:
            add_days = st.number_input("Extend by days", min_value=1, value=7, step=1)
        with colF:
            if st.button("Extend"):
                # Keep password; extend expiry (if no expiry, it remains no expiry)
                acc = [a for a in db["accounts"] if a.get("label") == sel][0]
                if acc.get("expires_on") is None:
                    st.info("This account is already 'no expiry'.")
                else:
                    left = days_remaining(acc["expires_on"])
                    base = date.today() if left is None or left < 0 else date.today() + timedelta(days=left)
                    new_exp = (base + timedelta(days=int(add_days))).strftime("%Y-%m-%d")
                    acc["expires_on"] = new_exp
                    save_auth_db(db)
                    st.success(f"Extended to {new_exp}")
                st.experimental_rerun()
        if st.button("Delete"):
            delete_account(db, sel)
            st.success(f"Deleted account: {sel}")
            st.experimental_rerun()
    else:
        st.info("No accounts to manage.")

    st.markdown("---")
    if st.button("Exit admin"):
        st.session_state.admin_mode = False
        st.session_state.admin_ok = False
        st.experimental_rerun()

# =========================
# Main App (원래 기능 그대로)
# =========================
def main_app():
    st.title(APP_TITLE)

    # 로그인 정보/남은 일수 배지
    if st.session_state.get("auth_label"):
        lbl = st.session_state["auth_label"]
        left_days = st.session_state.get("days_left")
        if left_days is None:
            st.info(f"Logged in as **{lbl}** · 남은일수: ∞")
        else:
            st.info(f"Logged in as **{lbl}** · 남은일수: {left_days}일")

    # ---- Sidebar (옵션 및 액션은 기존과 동일) ----
    uploaded = st.sidebar.file_uploader("Upload STL", type=["stl"])

    st.sidebar.header("Parameters")
    z_int        = st.sidebar.number_input("Z interval (mm)",  1.0, 1000.0, 15.0)
    feed         = st.sidebar.number_input("Feedrate (F)",     1,    100000, 2000)
    ref_x        = st.sidebar.number_input("Reference X",      value=0.0)
    ref_y        = st.sidebar.number_input("Reference Y",      value=0.0)

    st.sidebar.subheader("Extrusion options")
    e_on         = st.sidebar.checkbox("Insert E values")
    start_e_on   = st.sidebar.checkbox("Continuous Layer Printing", value=False, disabled=not e_on)
    start_e_val  = st.sidebar.number_input("Start E value", value=0.1, disabled=not (e_on and start_e_on))
    e0_on        = st.sidebar.checkbox("Add E0 at loop end", value=False, disabled=not e_on)

    st.sidebar.subheader("Path processing")
    trim_dist    = st.sidebar.number_input("Trim/Layer Width (mm)", 0.0, 1000.0, 50.0)
    min_spacing  = st.sidebar.number_input("Minimum point spacing (mm)", 0.0, 1000.0, 3.0)
    auto_start   = st.sidebar.checkbox("Start next layer near previous start")
    m30_on       = st.sidebar.checkbox("Append M30 at end", value=False)

    b1, b2 = st.sidebar.columns(2)
    slice_clicked = b1.button("슬라이싱", use_container_width=True)
    gen_clicked   = b2.button("G-code 생성", use_container_width=True)

    # ---- Mesh load (업로드 즉시) ----
    if uploaded is not None:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".stl") as tmp:
            tmp.write(uploaded.read())
            tmp_path = tmp.name
        mesh = trimesh.load_mesh(tmp_path)
        if not isinstance(mesh, trimesh.Trimesh):
            st.error("STL must contain a single mesh")
            st.stop()
        # Z 축 미세 확장
        scale_matrix = np.eye(4)
        scale_matrix[2, 2] = 1.0000001
        mesh.apply_transform(scale_matrix)
        st.session_state.mesh = mesh

    # ---- Actions ----
    if slice_clicked and st.session_state.mesh is not None:
        items = compute_slice_paths_with_travel(
            st.session_state.mesh,
            z_int=z_int,
            ref_pt_user=(ref_x, ref_y),
            trim_dist=trim_dist,
            min_spacing=min_spacing,
            auto_start=auto_start,
            e_on=e_on
        )
        st.session_state.paths_items = items
        st.success("Slicing complete")

    if gen_clicked and st.session_state.mesh is not None:
        gcode_text = generate_gcode(
            st.session_state.mesh,
            z_int=z_int,
            feed=feed,
            ref_pt_user=(ref_x, ref_y),
            e_on=e_on,
            start_e_on=start_e_on,
            start_e_val=start_e_val,
            e0_on=e0_on,
            trim_dist=trim_dist,
            min_spacing=min_spacing,
            auto_start=auto_start,
            m30_on=m30_on
        )
        st.session_state.gcode_text = gcode_text
        st.success("G-code ready")

    if st.session_state.get("gcode_text"):
        st.sidebar.download_button(
            "G-code 저장",
            st.session_state.gcode_text,
            file_name="output.gcode",
            mime="text/plain",
            use_container_width=True
        )

    # ---- Viewers (우측 큰 탭) ----
    tab_stl, tab_paths, tab_gcode = st.tabs(["STL Preview", "Sliced Paths (3D)", "G-code Viewer"])

    with tab_stl:
        if st.session_state.get("mesh") is not None:
            st.plotly_chart(
                plot_trimesh(st.session_state.mesh, height=820),
                use_container_width=True
            )
        else:
            st.info("STL을 업로드하세요.")

    with tab_paths:
        if st.session_state.get("paths_items") is not None:
            st.plotly_chart(
                plot_paths(st.session_state.paths_items, e_on=e_on, height=820),
                use_container_width=True
            )
        else:
            st.info("슬라이싱을 실행하세요.")

    with tab_gcode:
        if st.session_state.get("gcode_text"):
            st.code(st.session_state.gcode_text, language="gcode")
        else:
            st.info("G-code를 생성하세요.")


# =========================
# Router: Auth & Admin & Main
# =========================
# 모바일에서 비밀번호가 '유명무실'처럼 보이는 이유는
# 사이드바에 폼을 둘 경우 뷰어가 먼저 렌더링될 수 있어서입니다.
# -> 로그인 폼은 메인 화면에 먼저 표시하고, 로그인 전에 아무 뷰어도 렌더링하지 않습니다.
if st.session_state.get("admin_mode"):
    admin_screen()
elif not st.session_state.get("authenticated"):
    login_screen()
else:
    main_app()
