import streamlit as st
import numpy as np
import trimesh
import tempfile
import plotly.graph_objects as go
from typing import List, Tuple

st.set_page_config(page_title="3DCP Slicer", layout="wide")
st.title("3DCP Slicer")

# -----------------------
# Geometry helpers (연산식 그대로 유지)
# -----------------------
def trim_segment_end(segment, trim_distance=30.0):
    segment = np.array(segment)
    total_len = np.sum(np.linalg.norm(np.diff(segment, axis=0), axis=1))
    if total_len <= trim_distance:
        return segment
    trimmed = [segment[0]]
    acc = 0.0
    for i in range(1, len(segment)):
        p1, p2 = segment[i - 1], segment[i]
        d = np.linalg.norm(p2 - p1)
        if acc + d >= total_len - trim_distance:
            r = (total_len - trim_distance - acc) / d
            trimmed.append(p1 + (p2 - p1) * r)
            break
        trimmed.append(p2)
        acc += d
    return np.array(trimmed)

def simplify_segment(segment, min_dist):
    simplified = [segment[0]]
    for pt in segment[1:-1]:
        if np.linalg.norm(pt[:2] - simplified[-1][:2]) >= min_dist:
            simplified.append(pt)
    simplified.append(segment[-1])
    return np.array(simplified)

def shift_to_nearest_start(segment, ref_point):
    idx = np.argmin(np.linalg.norm(segment[:, :2] - ref_point, axis=1))
    return np.concatenate([segment[idx:], segment[1:idx + 1]], axis=0), segment[idx]

# -----------------------
# G-code generator (연산식 그대로 유지)
# -----------------------
def generate_gcode(mesh, z_int=30.0, feed=2000, ref_pt_user=(0.0, 0.0),
                   e_on=False, start_e_on=False, start_e_val=0.1, e0_on=False,
                   trim_dist=30.0, min_spacing=3.0, auto_start=False, m30_on=False):
    extrusion_k = 0.05
    g = ["; *** Generated by 3DCP Slicer ***", "G21", "G90"]
    if e_on:
        g.append("M83")

    z_max = mesh.bounds[1, 2]
    z_values = list(np.arange(z_int, z_max + 0.001, z_int))
    if abs(z_max - z_values[-1]) > 1e-3:
        z_values.append(z_max)
    z_values.append(z_max + 0.01)

    prev_start_xy = None
    for z in z_values:
        sec = mesh.section(plane_origin=[0,0,z], plane_normal=[0,0,1])
        if sec is None:
            continue
        try:
            slice2D, to3D = sec.to_2D()
        except Exception:
            continue
        segments = []
        for seg in slice2D.discrete:
            seg = np.array(seg)
            seg3d = (to3D @ np.hstack([seg, np.zeros((len(seg),1)), np.ones((len(seg),1))]).T).T[:, :3]
            segments.append(seg3d)
        if not segments:
            continue

        g.append(f"\n; ---------- Z = {z:.2f} mm ----------")
        if auto_start and prev_start_xy is not None:
            dists = [np.linalg.norm(s[0][:2] - prev_start_xy) for s in segments]
            first_idx = int(np.argmin(dists))
            segments = segments[first_idx:] + segments[:first_idx]
            ref_pt_layer = prev_start_xy
        else:
            ref_pt_layer = np.array(ref_pt_user)

        for i_seg, seg3d in enumerate(segments):
            shifted, _  = shift_to_nearest_start(seg3d, ref_pt_layer)
            trimmed     = trim_segment_end(shifted, trim_dist)
            simplified  = simplify_segment(trimmed, min_spacing)
            start       = simplified[0]

            g.append(f"G01 F{feed}")
            if start_e_on:
                g.append(f"G01 X{start[0]:.3f} Y{start[1]:.3f} Z{z:.3f} E{start_e_val:.5f}")
            else:
                g.append(f"G01 X{start[0]:.3f} Y{start[1]:.3f} Z{z:.3f}")

            for p1, p2 in zip(simplified[:-1], simplified[1:]):
                dist = np.linalg.norm(p2[:2] - p1[:2])
                if e_on:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f} E{dist * extrusion_k:.5f}")
                else:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f}")

            if e0_on:
                g.append("G01 E0")

            if i_seg == 0:
                prev_start_xy = start[:2]

    g.append(f"G01 F{feed}")
    if m30_on:
        g.append("M30")
    return "\n".join(g)

# -----------------------
# Slice path computation (미리보기용)
# -----------------------
def compute_slice_paths(mesh, z_int=30.0, ref_pt_user=(0.0, 0.0),
                        trim_dist=30.0, min_spacing=3.0, auto_start=False,
                        e_on=False):
    z_max = mesh.bounds[1, 2]
    z_values = list(np.arange(z_int, z_max + 0.001, z_int))
    if abs(z_max - z_values[-1]) > 1e-3:
        z_values.append(z_max)
    z_values.append(z_max + 0.01)

    prev_start_xy = None
    paths: List[Tuple[np.ndarray, np.ndarray | None]] = []
    for z in z_values:
        sec = mesh.section(plane_origin=[0,0,z], plane_normal=[0,0,1])
        if sec is None:
            continue
        try:
            slice2D, to3D = sec.to_2D()
        except Exception:
            continue

        segments = []
        for seg in slice2D.discrete:
            seg = np.array(seg)
            seg3d = (to3D @ np.hstack([seg, np.zeros((len(seg),1)), np.ones((len(seg),1))]).T).T[:, :3]
            segments.append(seg3d)
        if not segments:
            continue

        if auto_start and prev_start_xy is not None:
            dists = [np.linalg.norm(s[0][:2] - prev_start_xy) for s in segments]
            first_idx = int(np.argmin(dists))
            segments = segments[first_idx:] + segments[:first_idx]
            ref_pt_layer = prev_start_xy
        else:
            ref_pt_layer = np.array(ref_pt_user)

        for i_seg, seg3d in enumerate(segments):
            shifted, _ = shift_to_nearest_start(seg3d, ref_pt_layer)
            trimmed    = trim_segment_end(shifted, trim_dist)
            simplified = simplify_segment(trimmed, min_spacing)

            if e_on:
                extrusion_k = 0.05
                e_values = [0.0]
                total = 0.0
                for p1, p2 in zip(simplified[:-1], simplified[1:]):
                    dist = np.linalg.norm(p2[:2] - p1[:2])
                    total += dist * extrusion_k
                    e_values.append(total)
                paths.append((simplified, np.array(e_values)))
            else:
                paths.append((simplified, None))

            if i_seg == 0:
                prev_start_xy = simplified[0][:2]
    return paths

# -----------------------
# Plotly 시각화
# -----------------------
def plot_trimesh(mesh: trimesh.Trimesh, height=720) -> go.Figure:
    v = mesh.vertices
    f = mesh.faces
    fig = go.Figure(data=[go.Mesh3d(
        x=v[:,0], y=v[:,1], z=v[:,2],
        i=f[:,0], j=f[:,1], k=f[:,2],
        opacity=0.6, flatshading=True
    )])
    fig.update_layout(scene=dict(aspectmode="data"), height=height, margin=dict(l=0, r=0, t=10, b=0))
    return fig

def plot_paths(paths: List[Tuple[np.ndarray, np.ndarray | None]], e_on=False, height=720) -> go.Figure:
    fig = go.Figure()
    for poly, e_vals in paths:
        if e_on and e_vals is not None:
            fig.add_trace(go.Scatter3d(
                x=poly[:,0], y=poly[:,1], z=poly[:,2],
                mode="lines+text",
                line=dict(width=3),
                text=[f"E={e:.2f}" for e in e_vals],
                textposition="top center",
                showlegend=False
            ))
        else:
            fig.add_trace(go.Scatter3d(
                x=poly[:,0], y=poly[:,1], z=poly[:,2],
                mode="lines",
                line=dict(width=3),
                showlegend=False
            ))
    fig.update_layout(scene=dict(aspectmode="data"), height=height, margin=dict(l=0, r=0, t=10, b=0))
    return fig

# -----------------------
# 레이아웃: 왼쪽(좁게) / 오른쪽(큼직하게)
# -----------------------
left, right = st.columns([0.25, 0.75])  # 왼쪽 좁게, 오른쪽 크게

with left:
    # 업로더를 최상단에
    uploaded = st.file_uploader("Upload STL", type=["stl"])

    st.header("Parameters")
    z_int        = st.number_input("Z interval (mm)",  1.0, 1000.0, 15.0)
    feed         = st.number_input("Feedrate (F)",     1,    100000, 2000)
    ref_x        = st.number_input("Reference X",      value=0.0)
    ref_y        = st.number_input("Reference Y",      value=0.0)

    st.subheader("Extrusion options")
    e_on         = st.checkbox("Insert E values")
    start_e_on   = st.checkbox("Continuous Layer Printing", value=False, disabled=not e_on)
    start_e_val  = st.number_input("Start E value", value=0.1, disabled=not (e_on and start_e_on))
    e0_on        = st.checkbox("Add E0 at loop end", value=False, disabled=not e_on)

    st.subheader("Path processing")
    trim_dist    = st.number_input("Trim/Layer Width (mm)", 0.0, 1000.0, 50.0)
    min_spacing  = st.number_input("Minimum point spacing (mm)", 0.0, 1000.0, 3.0)
    auto_start   = st.checkbox("Start next layer near previous start")
    m30_on       = st.checkbox("Append M30 at end", value=False)

    # 버튼 폭 동일: 두 컬럼으로 정렬
    bcol1, bcol2 = st.columns(2)
    slice_clicked = bcol1.button("슬라이싱", use_container_width=True)
    gen_clicked   = bcol2.button("G-code 생성", use_container_width=True)

    if "mesh" not in st.session_state:
        st.session_state.mesh = None
    if "paths" not in st.session_state:
        st.session_state.paths = None
    if "gcode_text" not in st.session_state:
        st.session_state.gcode_text = None

    # STL 로드
    if uploaded is not None:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".stl") as tmp:
            tmp.write(uploaded.read())
            tmp_path = tmp.name
        mesh = trimesh.load_mesh(tmp_path)
        if not isinstance(mesh, trimesh.Trimesh):
            st.error("STL must contain a single mesh")
            st.stop()
        # Z 축 미세 확장 (기존 로직)
        scale_matrix = np.eye(4)
        scale_matrix[2, 2] = 1.0000001
        mesh.apply_transform(scale_matrix)
        st.session_state.mesh = mesh

    # 동작
    if slice_clicked and st.session_state.mesh is not None:
        paths = compute_slice_paths(
            st.session_state.mesh,
            z_int=z_int,
            ref_pt_user=(ref_x, ref_y),
            trim_dist=trim_dist,
            min_spacing=min_spacing,
            auto_start=auto_start,
            e_on=e_on
        )
        st.session_state.paths = paths
        st.success("Slicing complete")

    if gen_clicked and st.session_state.mesh is not None:
        gcode_text = generate_gcode(
            st.session_state.mesh,
            z_int=z_int,
            feed=feed,
            ref_pt_user=(ref_x, ref_y),
            e_on=e_on,
            start_e_on=start_e_on,
            start_e_val=start_e_val,
            e0_on=e0_on,
            trim_dist=trim_dist,
            min_spacing=min_spacing,
            auto_start=auto_start,
            m30_on=m30_on
        )
        st.session_state.gcode_text = gcode_text
        st.success("G-code ready")

    if st.session_state.get("gcode_text"):
        st.download_button("G-code 저장", st.session_state.gcode_text,
                           file_name="output.gcode", mime="text/plain", use_container_width=True)

with right:
    # 탭으로 큰 뷰어 3개 구성 (필요한 것만 표시)
    tab_stl, tab_paths, tab_gcode = st.tabs(["STL Preview", "Sliced Paths (3D)", "G-code Viewer"])

    with tab_stl:
        if st.session_state.get("mesh") is not None:
            st.plotly_chart(plot_trimesh(st.session_state.mesh, height=780), use_container_width=True)
        else:
            st.info("STL을 업로드하세요.")

    with tab_paths:
        if st.session_state.get("paths") is not None:
            st.plotly_chart(plot_paths(st.session_state.paths, e_on=e_on, height=780), use_container_width=True)
        else:
            st.info("슬라이싱을 실행하세요.")

    with tab_gcode:
        if st.session_state.get("gcode_text"):
            # 코드 뷰어: 라인 넘버 포함
            st.code(st.session_state.gcode_text, language="gcode")
        else:
            st.info("G-code를 생성하세요.")
