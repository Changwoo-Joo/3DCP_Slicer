import streamlit as st
import numpy as np
import trimesh
import tempfile
import plotly.graph_objects as go
from typing import List, Tuple, Optional
from datetime import date, datetime
from pathlib import Path  # íŒŒì¼ëª… ì¶”ì¶œìš©

# =========================
# App basics
# =========================
st.set_page_config(page_title="3DCP Slicer", layout="wide")
st.title("3DCP Slicer")

EXTRUSION_K = 0.05
PATH_COLOR = "#222222"  # ë‹¨ìƒ‰ ìœ ì§€

# =========================
# Helpers
# =========================
def trim_segment_end(segment, trim_distance=30.0):
    """XY ëˆ„ì  ê¸¸ì´ ê¸°ì¤€ìœ¼ë¡œ ë§ˆì§€ë§‰ trim_distanceë§Œí¼ ì˜ë¼ëƒ„."""
    segment = np.array(segment, dtype=float)
    if len(segment) < 2:
        return segment
    total_len = np.sum(np.linalg.norm(np.diff(segment, axis=0)[:, :2], axis=1))
    if total_len <= trim_distance:
        return segment
    trimmed = [segment[0]]
    acc = 0.0
    for i in range(1, len(segment)):
        p1, p2 = segment[i - 1], segment[i]
        d = np.linalg.norm((p2 - p1)[:2])
        if d == 0:
            continue
        if acc + d >= total_len - trim_distance:
            r = (total_len - trim_distance - acc) / d
            trimmed.append(p1 + (p2 - p1) * r)
            break
        trimmed.append(p2)
        acc += d
    return np.array(trimmed)

def simplify_segment(segment: np.ndarray, min_dist: float) -> np.ndarray:
    """
    XY ê¸°ì¤€ Ramerâ€“Douglasâ€“Peucker ê°„ì†Œí™”.
    - ì§ì„  êµ¬ê°„ì€ ì–‘ ëì ë§Œ ìœ ì§€ (ì¤‘ê°„ í¬ì¸íŠ¸ ì œê±°)
    - ê³¡ì„ /êº¾ì„ì´ ìˆëŠ” ë¶€ë¶„ë§Œ ì  ìœ ì§€
    - min_dist(=epsilon ê·œëª¨)ë¥¼ í‚¤ìš¸ìˆ˜ë¡ ë” ê³¼ê°íˆ ë‹¨ìˆœí™”
    """
    pts = np.asarray(segment, dtype=float)
    if len(pts) <= 2 or min_dist <= 0:
        return pts

    eps = float(min_dist) / 2.0  # ê¶Œì¥: ìµœì†Œ ê°„ê²©ì˜ ì ˆë°˜ ì •ë„ í—ˆìš© ì˜¤ì°¨

    def _perp_dist_xy(p, a, b) -> float:
        ab = b[:2] - a[:2]
        ap = p[:2] - a[:2]
        denom = np.dot(ab, ab)
        if denom <= 1e-18:
            return np.linalg.norm(ap)
        t = np.clip(np.dot(ap, ab) / denom, 0.0, 1.0)
        proj = a[:2] + t * ab
        return np.linalg.norm(p[:2] - proj)

    def _rdp_xy(points: np.ndarray, eps_val: float) -> np.ndarray:
        if len(points) <= 2:
            return points
        a = points[0]
        b = points[-1]
        dmax = -1.0
        idx = -1
        for i in range(1, len(points) - 1):
            d = _perp_dist_xy(points[i], a, b)
            if d > dmax:
                dmax = d
                idx = i
        if dmax <= eps_val:
            return np.vstack([a, b])  # ì§ì„  ê·¼ì‚¬ OK â†’ ëì ë§Œ
        left = _rdp_xy(points[: idx + 1], eps_val)
        right = _rdp_xy(points[idx:], eps_val)
        return np.vstack([left[:-1], right])  # ì¤‘ë³µ ì œê±°

    return _rdp_xy(pts, eps)

def shift_to_nearest_start(segment, ref_point):
    """ì‹œì‘ì ì„ ref_point(XY)ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì •ì ìœ¼ë¡œ ëŒë ¤ ë°°ì¹˜."""
    idx = np.argmin(np.linalg.norm(segment[:, :2] - ref_point, axis=1))
    return np.concatenate([segment[idx:], segment[:idx]], axis=0), segment[idx]

# =========================
# G-code generator
# =========================
def generate_gcode(mesh, z_int=30.0, feed=2000, ref_pt_user=(0.0, 0.0),
                   e_on=False, start_e_on=False, start_e_val=0.1, e0_on=False,
                   trim_dist=30.0, min_spacing=3.0, auto_start=False, m30_on=False):
    g = ["; *** Generated by 3DCP Slicer ***", "G21", "G90"]
    if e_on:
        g.append("M83")

    z_max = mesh.bounds[1, 2]
    z_values = list(np.arange(z_int, z_max + 0.001, z_int))
    if abs(z_max - z_values[-1]) > 1e-3:
        z_values.append(z_max)
    z_values.append(z_max + 0.01)  # ìµœìƒë‹¨ ìº¡ì³

    prev_start_xy = None
    for z in z_values:
        sec = mesh.section(plane_origin=[0, 0, z], plane_normal=[0, 0, 1])
        if sec is None:
            continue
        try:
            slice2D, to3D = sec.to_2D()
        except Exception:
            continue

        segments = []
        for seg in slice2D.discrete:
            seg = np.array(seg)
            seg3d = (to3D @ np.hstack([seg, np.zeros((len(seg), 1)), np.ones((len(seg), 1))]).T).T[:, :3]
            segments.append(seg3d)
        if not segments:
            continue

        g.append(f"\n; ---------- Z = {z:.2f} mm ----------")

        if auto_start and prev_start_xy is not None:
            dists = [np.linalg.norm(s[0][:2] - prev_start_xy) for s in segments]
            first_idx = int(np.argmin(dists))
            segments = segments[first_idx:] + segments[:first_idx]
            ref_pt_layer = prev_start_xy
        else:
            ref_pt_layer = np.array(ref_pt_user, dtype=float)

        for i_seg, seg3d in enumerate(segments):
            shifted, _ = shift_to_nearest_start(seg3d, ref_pt_layer)
            trimmed = trim_segment_end(shifted, trim_dist)
            simplified = simplify_segment(trimmed, min_spacing)
            start = simplified[0]

            g.append(f"G01 F{feed}")
            if start_e_on:
                g.append(f"G01 X{start[0]:.3f} Y{start[1]:.3f} Z{z:.3f} E{start_e_val:.5f}")
            else:
                g.append(f"G01 X{start[0]:.3f} Y{start[1]:.3f} Z{z:.3f}")

            for p1, p2 in zip(simplified[:-1], simplified[1:]):
                dist = np.linalg.norm(p2[:2] - p1[:2])
                if e_on:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f} E{dist * EXTRUSION_K:.5f}")
                else:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f}")

            if e0_on:
                g.append("G01 E0")

            if i_seg == 0:
                prev_start_xy = start[:2]

    g.append(f"G01 F{feed}")
    if m30_on:
        g.append("M30")
    return "\n".join(g)

# =========================
# Slice path computation (ë¯¸ë¦¬ë³´ê¸°ìš©)
# =========================
def compute_slice_paths_with_travel(
    mesh,
    z_int=30.0,
    ref_pt_user=(0.0, 0.0),
    trim_dist=30.0,
    min_spacing=3.0,
    auto_start=False,
    e_on=False
) -> List[Tuple[np.ndarray, Optional[np.ndarray], bool]]:
    z_max = mesh.bounds[1, 2]
    z_values = list(np.arange(z_int, z_max + 0.001, z_int))
    if abs(z_max - z_values[-1]) > 1e-3:
        z_values.append(z_max)
    z_values.append(z_max + 0.01)

    all_items: List[Tuple[np.ndarray, Optional[np.ndarray], bool]] = []
    prev_layer_last_end: Optional[np.ndarray] = None
    prev_start_xy = None

    for z in z_values:
        sec = mesh.section(plane_origin=[0, 0, z], plane_normal=[0, 0, 1])
        if sec is None:
            continue
        try:
            slice2D, to3D = sec.to_2D()
        except Exception:
            continue

        segments = []
        for seg in slice2D.discrete:
            seg = np.array(seg)
            seg3d = (to3D @ np.hstack([seg, np.zeros((len(seg), 1)), np.ones((len(seg), 1))]).T).T[:, :3]
            segments.append(seg3d)
        if not segments:
            continue

        if auto_start and prev_start_xy is not None:
            dists = [np.linalg.norm(s[0][:2] - prev_start_xy) for s in segments]
            first_idx = int(np.argmin(dists))
            segments = segments[first_idx:] + segments[:first_idx]
            ref_pt_layer = prev_start_xy
        else:
            ref_pt_layer = np.array(ref_pt_user, dtype=float)

        layer_polys: List[np.ndarray] = []
        for i_seg, seg3d in enumerate(segments):
            shifted, _ = shift_to_nearest_start(seg3d, ref_pt_layer)
            trimmed = trim_segment_end(shifted, trim_dist)
            simplified = simplify_segment(trimmed, min_spacing)
            layer_polys.append(simplified.copy())
            if i_seg == 0:
                prev_start_xy = simplified[0][:2]

        if not layer_polys:
            continue

        first_poly_start = layer_polys[0][0]
        if prev_layer_last_end is not None:
            travel = np.vstack([prev_layer_last_end, first_poly_start])
            all_items.append((travel, np.array([0.0, 0.0]) if e_on else None, True))

        for poly in layer_polys:
            if e_on:
                e_vals = [0.0]
                total = 0.0
                for p1, p2 in zip(poly[:-1], poly[1:]):
                    dist = np.linalg.norm(p2[:2] - p1[:2])
                    total += dist * EXTRUSION_K
                    e_vals.append(total)
                all_items.append((poly, np.array(e_vals), False))
            else:
                all_items.append((poly, None, False))

        prev_layer_last_end = layer_polys[-1][-1]

    return all_items

# =========================
# Plotly: STL & Paths
# =========================
def plot_trimesh(mesh: trimesh.Trimesh, height=820) -> go.Figure:
    v = mesh.vertices
    f = mesh.faces
    fig = go.Figure(data=[go.Mesh3d(
        x=v[:, 0], y=v[:, 1], z=v[:, 2],
        i=f[:, 0], j=f[:, 1], k=f[:, 2],
        color="#888888",
        opacity=0.6,
        flatshading=True
    )])
    fig.update_layout(scene=dict(aspectmode="data"),
                      height=height, margin=dict(l=0, r=0, t=10, b=0))
    return fig

def plot_paths(items: List[Tuple[np.ndarray, Optional[np.ndarray], bool]], e_on=False, height=820) -> go.Figure:
    fig = go.Figure()
    for poly, e_vals, is_travel in items:
        if e_on and e_vals is not None:
            for (p1, p2, e1, e2) in zip(poly[:-1], poly[1:], e_vals[:-1], e_vals[1:]):
                dash_style = "solid" if (e2 - e1) > 1e-12 else "dot"
                fig.add_trace(go.Scatter3d(
                    x=[p1[0], p2[0]], y=[p1[1], p2[1]], z=[p1[2], p2[2]],
                    mode="lines",
                    line=dict(width=3, dash=dash_style, color=PATH_COLOR),
                    showlegend=False
                ))
        else:
            fig.add_trace(go.Scatter3d(
                x=poly[:, 0], y=poly[:, 1], z=poly[:, 2],
                mode="lines", line=dict(width=3, color=PATH_COLOR),
                showlegend=False
            ))
    fig.update_layout(scene=dict(aspectmode="data"),
                      height=height, margin=dict(l=0, r=0, t=10, b=0))
    return fig

# =========================
# Session init
# =========================
if "mesh" not in st.session_state:
    st.session_state.mesh = None
if "paths_items" not in st.session_state:
    st.session_state.paths_items = None
if "gcode_text" not in st.session_state:
    st.session_state.gcode_text = None
if "base_name" not in st.session_state:
    st.session_state.base_name = "output"
# ì›ë³¸ ë©”ì‹œ ë³´ê´€: ë³€í™˜ì€ í•­ìƒ ì—¬ê¸°ì„œë¶€í„° ì¬ì ìš©
if "orig_mesh" not in st.session_state:
    st.session_state.orig_mesh = None

# ==== Transform defaults (ensure variables always exist) ====
for k, v in {
    "scale_percent": 100.0,
    "rot_x_deg": 0.0,
    "rot_y_deg": 0.0,
    "rot_z_deg": 0.0,
    "shift_x": 0.0,
    "shift_y": 0.0,
    "shift_z": 0.0,
}.items():
    if k not in st.session_state:
        st.session_state[k] = v

# ==== Rapid session keys (ì¶”ê°€ ê¸°ëŠ¥ìš©) ====
if "show_rapid_panel" not in st.session_state:
    st.session_state.show_rapid_panel = False
if "rapid_rx" not in st.session_state:
    st.session_state.rapid_rx = 0.0
if "rapid_ry" not in st.session_state:
    st.session_state.rapid_ry = 0.0
if "rapid_rz" not in st.session_state:
    st.session_state.rapid_rz = 0.0
if "rapid_text" not in st.session_state:
    st.session_state.rapid_text = None

# =========================
# Sidebar (Access Key + ë§Œë£Œì¼)
# =========================
st.sidebar.header("Access")

ALLOWED_WITH_EXPIRY = {
    "robotics5107": None,
    "kmou*": "2026-12-31",
}
access_key = st.sidebar.text_input("Access Key", type="password", key="access_key")

def check_key_valid(k: str):
    if not k or k not in ALLOWED_WITH_EXPIRY:
        return False, None, None, "ìœ íš¨í•˜ì§€ ì•Šì€ í‚¤ì…ë‹ˆë‹¤."
    exp = ALLOWED_WITH_EXPIRY[k]
    if exp is None:
        return True, None, None, "ë§Œë£Œì¼ ì—†ìŒ"
    try:
        exp_date = date.fromisoformat(exp)
    except Exception:
        return False, None, None, "í‚¤ ë§Œë£Œì¼ í˜•ì‹ ì˜¤ë¥˜(YYYY-MM-DD)."
    today = date.today()
    remaining = (exp_date - today).days
    if remaining < 0:
        return False, exp_date, remaining, f"ë§Œë£Œì¼ ê²½ê³¼: {exp_date.isoformat()}"
    elif remaining == 0:
        return True, exp_date, remaining, f"ì˜¤ëŠ˜ ë§Œë£Œ ({exp_date.isoformat()})"
    else:
        return True, exp_date, remaining, f"ë§Œë£Œì¼: {exp_date.isoformat()} Â· {remaining}ì¼ ë‚¨ìŒ"

KEY_OK, EXP_DATE, REMAINING, STATUS_TXT = check_key_valid(access_key)

# ìƒíƒœ í‘œì‹œ
if access_key:
    if KEY_OK:
        if EXP_DATE is None:
            st.sidebar.success(STATUS_TXT)
        else:
            d_mark = f"D-{REMAINING}" if REMAINING > 0 else "D-DAY"
            st.sidebar.info(f"{STATUS_TXT} ({d_mark})")
    else:
        st.sidebar.error(STATUS_TXT)
else:
    st.sidebar.warning("Access Keyë¥¼ ì…ë ¥í•˜ì„¸ìš”.")

# ì—…ë¡œë“œëŠ” í‚¤ ì—†ìœ¼ë©´ ë¹„í™œì„±í™”
uploaded = st.sidebar.file_uploader("Upload STL", type=["stl"], disabled=not KEY_OK)

st.sidebar.header("Parameters")
z_int = st.sidebar.number_input("Z interval (mm)", 1.0, 1000.0, 15.0)
feed = st.sidebar.number_input("Feedrate (F)", 1, 100000, 2000)
ref_x = st.sidebar.number_input("Reference X", value=0.0)
ref_y = st.sidebar.number_input("Reference Y", value=0.0)

st.sidebar.subheader("Extrusion options")
e_on = st.sidebar.checkbox("Insert E values")
start_e_on = st.sidebar.checkbox("Continuous Layer Printing", value=False, disabled=not e_on)
start_e_val = st.sidebar.number_input("Start E value", value=0.1, disabled=not (e_on and start_e_on))
e0_on = st.sidebar.checkbox("Add E0 at loop end", value=False, disabled=not e_on)

st.sidebar.subheader("Path processing")
trim_dist = st.sidebar.number_input("Trim/Layer Width (mm)", 0.0, 1000.0, 50.0)
min_spacing = st.sidebar.number_input("Minimum point spacing (mm)", 0.0, 1000.0, 3.0)
auto_start = st.sidebar.checkbox("Start next layer near previous start")
m30_on = st.sidebar.checkbox("Append M30 at end", value=False)

# === Geometry Transform (scale/rotate/shift) ===
st.sidebar.subheader("Geometry Transform")
st.sidebar.number_input("Scale (%)", min_value=0.0001, max_value=100000.0, step=1.0,
                        key="scale_percent", help="100%=ì›ë³¸, 200%=2ë°° í™•ëŒ€, 50%=ì ˆë°˜")
st.sidebar.number_input("Rotate X (deg)", step=1.0, key="rot_x_deg", help="Xì¶• ê¸°ì¤€ íšŒì „ (ë„)")
st.sidebar.number_input("Rotate Y (deg)", step=1.0, key="rot_y_deg", help="Yì¶• ê¸°ì¤€ íšŒì „ (ë„)")
st.sidebar.number_input("Rotate Z (deg)", step=1.0, key="rot_z_deg", help="Zì¶• ê¸°ì¤€ íšŒì „ (ë„)")
st.sidebar.number_input("Shift X (mm)", step=1.0, key="shift_x")
st.sidebar.number_input("Shift Y (mm)", step=1.0, key="shift_y")
st.sidebar.number_input("Shift Z (mm)", step=1.0, key="shift_z")

# âœ… í”¼ë²— ì„ íƒ: ëª¨ë¸ ì¤‘ì‹¬ / ì›”ë“œ ì›ì 
pivot_choice = st.sidebar.selectbox(
    "Transform Pivot",
    ["Model center (recommended)", "World origin (0,0,0)"],
    index=0,
    help="íšŒì „/í™•ëŒ€ì˜ ê¸°ì¤€ì . ëª¨ë¸ ì¤‘ì‹¬ ê¶Œì¥"
)

apply_transform_clicked = st.sidebar.button("Apply Transform", use_container_width=True, disabled=not KEY_OK)

b1 = st.sidebar.container()
b2 = st.sidebar.container()

slice_clicked = b1.button("Slice Model", use_container_width=True)
gen_clicked = b2.button("Generate G-Code", use_container_width=True)

# =========================
# Load mesh on upload
# =========================
if uploaded is not None:
    with tempfile.NamedTemporaryFile(delete=False, suffix=".stl") as tmp:
        tmp.write(uploaded.read())
        tmp_path = tmp.name
    mesh = trimesh.load_mesh(tmp_path)
    if not isinstance(mesh, trimesh.Trimesh):
        st.error("STL must contain a single mesh")
        st.stop()
    # Z ì¶• ë¯¸ì„¸ í™•ì¥ (ìµœëŒ€ Z ì ˆë‹¨ë©´ ì¸ì‹ ë³´ì •)
    scale_matrix = np.eye(4)
    scale_matrix[2, 2] = 1.0000001
    mesh.apply_transform(scale_matrix)

    # ì›ë³¸ê³¼ ì‘ì—…ìš© ë³µì‚¬ ì €ì¥
    st.session_state.orig_mesh = mesh.copy()
    st.session_state.mesh = mesh.copy()

    # ì—…ë¡œë“œ ì›ë³¸ íŒŒì¼ëª… ì €ì¥ (í™•ì¥ì ì œì™¸)
    st.session_state.base_name = Path(uploaded.name).stem or "output"

# =========================
# Apply Transform (Pivot-aware: center/origin)
# =========================
def _rot_x(theta_rad: float) -> np.ndarray:
    c, s = np.cos(theta_rad), np.sin(theta_rad)
    R = np.eye(4)
    R[1, 1], R[1, 2] = c, -s
    R[2, 1], R[2, 2] = s,  c
    return R

def _rot_y(theta_rad: float) -> np.ndarray:
    c, s = np.cos(theta_rad), np.sin(theta_rad)
    R = np.eye(4)
    R[0, 0], R[0, 2] =  c, s
    R[2, 0], R[2, 2] = -s, c
    return R

def _rot_z(theta_rad: float) -> np.ndarray:
    c, s = np.cos(theta_rad), np.sin(theta_rad)
    R = np.eye(4)
    R[0, 0], R[0, 1] = c, -s
    R[1, 0], R[1, 1] = s,  c
    return R

if apply_transform_clicked:
    if st.session_state.orig_mesh is None:
        st.warning("ë¨¼ì € STLì„ ì—…ë¡œë“œí•˜ì„¸ìš”.")
    else:
        # í•­ìƒ 'ì›ë³¸' ê¸°ì¤€ìœ¼ë¡œ ë³€í™˜(ëˆ„ì ì˜¤ì°¨ ë°©ì§€)
        m = st.session_state.orig_mesh.copy()

        # === í”¼ë²— ê³„ì‚° ===
        use_center_pivot = (pivot_choice.startswith("Model center"))
        if use_center_pivot:
            (minx, miny, minz), (maxx, maxy, maxz) = m.bounds
            cx, cy, cz = ((minx + maxx) / 2.0, (miny + maxy) / 2.0, (minz + maxz) / 2.0)
        else:
            cx, cy, cz = (0.0, 0.0, 0.0)

        # í—¬í¼: 4x4 ë³€í™˜ í–‰ë ¬ë“¤
        def _T(tx, ty, tz):
            T = np.eye(4); T[:3, 3] = [tx, ty, tz]; return T
        def _S(s):
            M = np.eye(4); M[0,0]=M[1,1]=M[2,2]=s; return M

        # ì…ë ¥ ê°’
        s  = float(st.session_state.scale_percent) / 100.0
        rx = np.deg2rad(st.session_state.rot_x_deg)
        ry = np.deg2rad(st.session_state.rot_y_deg)
        rz = np.deg2rad(st.session_state.rot_z_deg)

        # ìˆœì„œ: (ì„¼í„°ë¡œ ì´ë™) â†’ ìŠ¤ì¼€ì¼ â†’ íšŒì „X â†’ íšŒì „Y â†’ íšŒì „Z â†’ (ì„¼í„° ë³µê·€)
        M_total = (
            _T(cx, cy, cz) @ _rot_z(rz) @ _rot_y(ry) @ _rot_x(rx) @ _S(s) @ _T(-cx, -cy, -cz)
        )
        m.apply_transform(M_total)

        # ë§ˆì§€ë§‰: ì‚¬ìš©ì ì‹œí”„íŠ¸
        m.apply_transform(_T(st.session_state.shift_x, st.session_state.shift_y, st.session_state.shift_z))

        st.session_state.mesh = m  # ë·°ì–´/ìŠ¬ë¼ì´ì„œ ëŒ€ìƒ ë©”ì‹œ ê°±ì‹ 
        st.session_state.paths_items = None  # ì´ì „ ìŠ¬ë¼ì´ìŠ¤ ë¬´íš¨í™”
        st.session_state.gcode_text = None   # ì´ì „ G-code ë¬´íš¨í™”
        st.success("ë³€í™˜ ì ìš© ì™„ë£Œ: ì„ íƒí•œ Pivot ê¸°ì¤€ìœ¼ë¡œ íšŒì „/í™•ëŒ€ê°€ ì ìš©ë˜ì—ˆê³ , ì´ ìƒíƒœë¡œ ìŠ¬ë¼ì´ì‹±/ìƒì„±ë©ë‹ˆë‹¤.")

# =========================
# Actions
# =========================
if KEY_OK and slice_clicked and st.session_state.mesh is not None:
    items = compute_slice_paths_with_travel(
        st.session_state.mesh,
        z_int=z_int,
        ref_pt_user=(ref_x, ref_y),
        trim_dist=trim_dist,
        min_spacing=min_spacing,
        auto_start=auto_start,
        e_on=e_on
    )
    st.session_state.paths_items = items
    st.success("Slicing complete")

if KEY_OK and gen_clicked and st.session_state.mesh is not None:
    gcode_text = generate_gcode(
        st.session_state.mesh,
        z_int=z_int,
        feed=feed,
        ref_pt_user=(ref_x, ref_y),
        e_on=e_on,
        start_e_on=start_e_on,
        start_e_val=start_e_val,
        e0_on=e0_on,
        trim_dist=trim_dist,
        min_spacing=min_spacing,
        auto_start=auto_start,
        m30_on=m30_on
    )
    st.session_state.gcode_text = gcode_text
    st.success("G-code ready")

if st.session_state.get("gcode_text"):
    base = st.session_state.get("base_name", "output")
    st.sidebar.download_button(
        "G-code ì €ì¥",
        st.session_state.gcode_text,
        file_name=f"{base}.gcode",
        mime="text/plain",
        use_container_width=True
    )

# =========================
# >>> Rapid(MODX) ì¶”ê°€ ê¸°ëŠ¥ (cone1500 í˜•ì‹) <<<
# =========================
def _fmt_pos(v: float) -> str:
    # +0000.0
    s = f"{v:+.1f}"
    sign = s[0]
    intpart, dec = s[1:].split(".")
    intpart = intpart.zfill(4)
    return f"{sign}{intpart}.{dec}"

def _fmt_ang(v: float) -> str:
    # +000.00
    s = f"{v:+.2f}"
    sign = s[0]
    intpart, dec = s[1:].split(".")
    intpart = intpart.zfill(3)
    return f"{sign}{intpart}.{dec}"

PAD_LINE = '+0000.0,+0000.0,+0000.0,+000.00,+000.00,+000.00,+0000.0,+0000.0,+0000.0,+0000.0'
MAX_LINES = 64000

def _extract_xyz_lines_count(gcode_text: str) -> int:
    """G-codeì—ì„œ X/Y/Z ì¢Œí‘œ ì§€ì •ì´ í¬í•¨ëœ G0/G1 ë¼ì¸ì˜ ê°œìˆ˜ë§Œ ì¹´ìš´íŠ¸"""
    cnt = 0
    for raw in gcode_text.splitlines():
        t = raw.strip()
        if not (t.startswith("G0") or t.startswith("G00") or t.startswith("G1") or t.startswith("G01")):
            continue
        has_xyz = any(p.startswith(("X", "Y", "Z")) for p in t.split())
        if has_xyz:
            cnt += 1
    return cnt

def gcode_to_cone1500_module(gcode_text: str, rx: float, ry: float, rz: float) -> str:
    """
    cone1500.modx ìŠ¤íƒ€ì¼ MODULE ìƒì„±:
      MODULE Converted
      VAR string sFileCount := "64000";
      VAR string d3dpDynLoad{64000} := [
        "X,Y,Z,Rx,Ry,Rz,A1,A2,A3,A4",
        ...
      ];
      ENDMODULE
    ì¢Œí‘œ ë¼ì¸ì´ ë¶€ì¡±í•˜ë©´ PAD_LINEìœ¼ë¡œ ì±„ì›€(ì •í™•íˆ 64,000ì¤„).
    """
    lines_out = []
    cur_x = 0.0
    cur_y = 0.0
    cur_z = 0.0
    frx = _fmt_ang(rx)
    fry = _fmt_ang(ry)
    frz = _fmt_ang(rz)
    tail = "+0000.0,+0000.0,+0000.0,+0000.0"

    for raw in gcode_text.splitlines():
        t = raw.strip()
        if not t or not (t.startswith("G0") or t.startswith("G00") or t.startswith("G1") or t.startswith("G01")):
            continue

        parts = t.split()
        has_xyz = False
        for p in parts:
            if p.startswith("X"):
                try:
                    cur_x = float(p[1:])
                    has_xyz = True
                except:
                    pass
            elif p.startswith("Y"):
                try:
                    cur_y = float(p[1:])
                    has_xyz = True
                except:
                    pass
            elif p.startswith("Z"):
                try:
                    cur_z = float(p[1:])
                    has_xyz = True
                except:
                    pass

        if not has_xyz:
            continue

        fx = _fmt_pos(cur_x)
        fy = _fmt_pos(cur_y)
        fz = _fmt_pos(cur_z)
        lines_out.append(f'{fx},{fy},{fz},{frx},{fry},{frz},{tail}')
        if len(lines_out) >= MAX_LINES:
            break

    # íŒ¨ë”©
    while len(lines_out) < MAX_LINES:
        lines_out.append(PAD_LINE)

    # MODULE ë˜í•‘
    ts = datetime.now().strftime("%Y-%m-%d %p %I:%M:%S")
    header = (
        "MODULE Converted\n"
        "!***************************************************************...****************************************************************\n"
        "!*\n"
        f"!*** Generated {ts} by Gcodeâ†’RAPID converter.\n"
        "!\n"
        "!*** data3dp syntax: X(mm), Y(mm), Z(mm), Rx(deg), Ry(deg), Rz(deg), A1,A2,A3,A4\n"
        "!\n"
        "!***************************************************************...****************************************************************\n"
    )
    cnt_str = str(MAX_LINES)
    open_decl = f'VAR string sFileCount:="{cnt_str}";\nVAR string d3dpDynLoad{{{cnt_str}}}:=[\n'
    body = ""
    for i, ln in enumerate(lines_out):
        q = f'"{ln}"'
        if i < len(lines_out) - 1:
            body += q + ",\n"
        else:
            body += q + "\n"
    close_decl = "];\nENDMODULE\n"
    return header + open_decl + body + close_decl

# ì‚¬ì´ë“œë°”: Generate Rapid
st.sidebar.markdown("---")
if KEY_OK:
    if st.sidebar.button("Generate Rapid", use_container_width=True):
        st.session_state.show_rapid_panel = True

    if st.session_state.show_rapid_panel:
        with st.sidebar.expander("Rapid Settings", expanded=True):
            st.session_state.rapid_rx = st.number_input("Rx (deg)", value=float(st.session_state.rapid_rx), step=0.1, format="%.2f")
            st.session_state.rapid_ry = st.number_input("Ry (deg)", value=float(st.session_state.rapid_ry), step=0.1, format="%.2f")
            st.session_state.rapid_rz = st.number_input("Rz (deg)", value=float(st.session_state.rapid_rz), step=0.1, format="%.2f")

            gtxt = st.session_state.get("gcode_text")
            over = None
            if gtxt is not None:
                xyz_count = _extract_xyz_lines_count(gtxt)
                over = (xyz_count > MAX_LINES)

            save_rapid_clicked = st.button("Save Rapid", use_container_width=True, disabled=(gtxt is None))
            if gtxt is None:
                st.info("ë¨¼ì € Generate G-Codeë¡œ G-codeë¥¼ ìƒì„±í•˜ì„¸ìš”.")
            elif over:
                st.error("G-codeê°€ 64,000ì¤„ì„ ì´ˆê³¼í•˜ì—¬ Rapid íŒŒì¼ ë³€í™˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            elif save_rapid_clicked:
                st.session_state.rapid_text = gcode_to_cone1500_module(
                    gtxt,
                    rx=st.session_state.rapid_rx,
                    ry=st.session_state.rapid_ry,
                    rz=st.session_state.rapid_rz,
                )
                st.success("Rapid(MODX, cone1500 í˜•ì‹) ë³€í™˜ ì™„ë£Œ")

            if st.session_state.get("rapid_text"):
                base = st.session_state.get("base_name", "output")
                st.download_button(
                    "Rapid ì €ì¥ (.modx)",
                    st.session_state.rapid_text,
                    file_name=f"{base}.modx",
                    mime="text/plain",
                    use_container_width=True
                )

# =========================
# Right: Viewers (í¬ê²Œ)
# =========================
tab_stl, tab_paths, tab_gcode = st.tabs(["STL Preview", "Sliced Paths (3D)", "G-code Viewer"])

with tab_stl:
    if st.session_state.get("mesh") is not None:
        mesh = st.session_state.mesh
        st.plotly_chart(
            plot_trimesh(mesh, height=820),
            use_container_width=True
        )

        # === Size & Coordinate Range í‘œì‹œ (ë³€í™˜ ì ìš© í›„ í˜„ì¬ ë©”ì‹œ ê¸°ì¤€) ===
        bounds = mesh.bounds  # [[xmin, ymin, zmin], [xmax, ymax, zmax]]
        (xmin, ymin, zmin), (xmax, ymax, zmax) = bounds
        size_x = xmax - xmin
        size_y = ymax - ymin
        size_z = zmax - zmin

        st.markdown("### ğŸ“ Mesh Size & Coordinate Range")
        st.write(f"**Size (X, Y, Z):** {size_x:.2f} mm Ã— {size_y:.2f} mm Ã— {size_z:.2f} mm")
        st.write(f"**X range:** {xmin:.2f} â†’ {xmax:.2f} mm")
        st.write(f"**Y range:** {ymin:.2f} â†’ {ymax:.2f} mm")
        st.write(f"**Z range:** {zmin:.2f} â†’ {zmax:.2f} mm")
    else:
        st.info("STLì„ ì—…ë¡œë“œí•˜ì„¸ìš”.")

with tab_paths:
    if st.session_state.get("paths_items") is not None:
        st.plotly_chart(
            plot_paths(st.session_state.paths_items, e_on=e_on, height=820),
            use_container_width=True
        )
    else:
        st.info("ìŠ¬ë¼ì´ì‹±ì„ ì‹¤í–‰í•˜ì„¸ìš”.")

with tab_gcode:
    if st.session_state.get("gcode_text"):
        st.code(st.session_state.gcode_text, language="gcode")
    else:
        st.info("G-codeë¥¼ ìƒì„±í•˜ì„¸ìš”.")

# í‚¤ê°€ ì—†ê±°ë‚˜ ë§Œë£Œ ì‹œ ì•ˆë‚´
if not KEY_OK:
    st.warning("ìœ íš¨í•œ Access Keyë¥¼ ì…ë ¥í•´ì•¼ í”„ë¡œê·¸ë¨ì´ ì‘ë™í•©ë‹ˆë‹¤. (ì—…ë¡œë“œ/ìŠ¬ë¼ì´ì‹±/G-code ë²„íŠ¼ ë¹„í™œì„±í™”)")
