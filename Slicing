import streamlit as st
import numpy as np
import trimesh
import tempfile
import os
from typing import List, Tuple
import plotly.graph_objects as go

# =========================
# Security (same as before)
# =========================
PASSWORD = "darobotics*"

if "authenticated" not in st.session_state:
    st.session_state.authenticated = False

def check_login():
    if st.session_state.get("password", "") == PASSWORD:
        st.session_state.authenticated = True

if not st.session_state.authenticated:
    st.title("🔒 비밀번호 입력")
    st.text_input("비밀번호를 입력하세요", type="password", key="password", on_change=check_login)
    st.stop()

# =========================
# App Title & Intro
# =========================
st.set_page_config(page_title="STL → G-code 컨버터 (3D Viewer)", layout="wide")
st.title("🛠️ STL → G-code 컨버터 (+ 3D Viewer)")
st.markdown(
    """STL파일을 업로드하면 **우측에 3D 미리보기**가 나타납니다.  
좌측 파라미터로 조건을 설정하고 **슬라이싱** 버튼을 누르면, **슬라이스 경로(3D)**가 표시됩니다.  
이후 **G-code 저장** 버튼으로 내려받을 수 있습니다.  
궁금하신 사항은 동아로보틱스 기술연구소 주창우부장(010-6754-2575)로 연락주세요."""
)

# =========================
# Geometry helpers (unchanged math)
# =========================
def trim_segment_end(segment, trim_distance=30.0):
    segment = np.array(segment)
    total_len = np.sum(np.linalg.norm(np.diff(segment, axis=0), axis=1))
    if total_len <= trim_distance:
        return segment
    trimmed = [segment[0]]
    acc = 0.0
    for i in range(1, len(segment)):
        p1, p2 = segment[i - 1], segment[i]
        d = np.linalg.norm(p2 - p1)
        if acc + d >= total_len - trim_distance:
            r = (total_len - trim_distance - acc) / d
            trimmed.append(p1 + (p2 - p1) * r)
            break
        trimmed.append(p2)
        acc += d
    return np.array(trimmed)

def simplify_segment(segment, min_dist):
    simplified = [segment[0]]
    for pt in segment[1:-1]:
        if np.linalg.norm(pt[:2] - simplified[-1][:2]) >= min_dist:
            simplified.append(pt)
    simplified.append(segment[-1])
    return np.array(simplified)

def shift_to_nearest_start(segment, ref_point):
    idx = np.argmin(np.linalg.norm(segment[:, :2] - ref_point, axis=1))
    return np.concatenate([segment[idx:], segment[1:idx + 1]], axis=0), segment[idx]

# =========================
# Core: generate_gcode (kept same logic)
# =========================
def generate_gcode(mesh, z_int=30.0, feed=2000, ref_pt_user=(0.0, 0.0),
                   e_on=False, start_e_on=False, start_e_val=0.1, e0_on=False,
                   trim_dist=30.0, min_spacing=3.0, auto_start=False, m30_on=False):
    extrusion_k = 0.05
    g = ["; *** Generated by STL→G-code Streamlit Exporter ***", "G21", "G90"]
    if e_on:
        g.append("M83")

    z_max = mesh.bounds[1, 2]
    z_values = list(np.arange(z_int, z_max + 0.001, z_int))
    if abs(z_max - z_values[-1]) > 1e-3:
        z_values.append(z_max)
    z_values.append(z_max + 0.01)

    prev_start_xy = None

    for z in z_values:
        sec = mesh.section(plane_origin=[0,0,z], plane_normal=[0,0,1])
        if sec is None:
            continue
        try:
            slice2D, to3D = sec.to_2D()
        except Exception:
            continue
        segments = []
        for seg in slice2D.discrete:
            seg = np.array(seg)
            seg3d = (to3D @ np.hstack([seg, np.zeros((len(seg),1)), np.ones((len(seg),1))]).T).T[:, :3]
            segments.append(seg3d)
        if not segments:
            continue

        g.append(f"\n; ---------- Z = {z:.2f} mm ----------")

        if auto_start and prev_start_xy is not None:
            dists = [np.linalg.norm(s[0][:2] - prev_start_xy) for s in segments]
            first_idx = int(np.argmin(dists))
            segments = segments[first_idx:] + segments[:first_idx]
            ref_pt_layer = prev_start_xy
        else:
            ref_pt_layer = np.array(ref_pt_user)

        for i_seg, seg3d in enumerate(segments):
            shifted, _  = shift_to_nearest_start(seg3d, ref_pt_layer)
            trimmed     = trim_segment_end(shifted, trim_dist)
            simplified  = simplify_segment(trimmed, min_spacing)
            start       = simplified[0]

            g.append(f"G01 F{feed}")
            if start_e_on:
                g.append(f"G01 X{start[0]:.3f} Y{start[1]:.3f} Z{z:.3f} E{start_e_val:.5f}")
            else:
                g.append(f"G01 X{start[0]:.3f} Y{start[1]:.3f} Z{z:.3f}")

            for p1, p2 in zip(simplified[:-1], simplified[1:]):
                dist = np.linalg.norm(p2[:2] - p1[:2])
                if e_on:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f} E{dist * 0.05:.5f}")
                else:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f}")

            if e0_on:
                g.append("G01 E0")

            if i_seg == 0:
                prev_start_xy = start[:2]

    g.append(f"G01 F{feed}")
    if m30_on:
        g.append("M30")
    return "\n".join(g)

# =========================
# NEW: Slicing path generator for 3D display
#      (uses identical math/steps as generate_gcode)
# =========================
def compute_slice_paths(mesh, z_int=30.0, ref_pt_user=(0.0, 0.0),
                        trim_dist=30.0, min_spacing=3.0, auto_start=False) -> List[np.ndarray]:
    """
    Returns a list of polylines (Nx3 arrays) across all layers,
    following exactly the same processing pipeline as generate_gcode,
    but without creating G-code strings.
    """
    z_max = mesh.bounds[1, 2]
    z_values = list(np.arange(z_int, z_max + 0.001, z_int))
    if abs(z_max - z_values[-1]) > 1e-3:
        z_values.append(z_max)
    z_values.append(z_max + 0.01)

    prev_start_xy = None
    polylines_3d: List[np.ndarray] = []

    for z in z_values:
        sec = mesh.section(plane_origin=[0,0,z], plane_normal=[0,0,1])
        if sec is None:
            continue
        try:
            slice2D, to3D = sec.to_2D()
        except Exception:
            continue

        segments = []
        for seg in slice2D.discrete:
            seg = np.array(seg)
            seg3d = (to3D @ np.hstack([seg, np.zeros((len(seg),1)), np.ones((len(seg),1))]).T).T[:, :3]
            segments.append(seg3d)
        if not segments:
            continue

        if auto_start and prev_start_xy is not None:
            dists = [np.linalg.norm(s[0][:2] - prev_start_xy) for s in segments]
            first_idx = int(np.argmin(dists))
            segments = segments[first_idx:] + segments[:first_idx]
            ref_pt_layer = prev_start_xy
        else:
            ref_pt_layer = np.array(ref_pt_user)

        for i_seg, seg3d in enumerate(segments):
            shifted, _  = shift_to_nearest_start(seg3d, ref_pt_layer)
            trimmed     = trim_segment_end(shifted, trim_dist)
            simplified  = simplify_segment(trimmed, min_spacing)
            polylines_3d.append(simplified.copy())
            if i_seg == 0:
                prev_start_xy = simplified[0][:2]

    return polylines_3d

# =========================
# Plotly 3D viewers
# =========================
def plot_trimesh(mesh: trimesh.Trimesh, title="STL Preview") -> go.Figure:
    v = mesh.vertices
    f = mesh.faces
    fig = go.Figure(
        data=[
            go.Mesh3d(
                x=v[:,0], y=v[:,1], z=v[:,2],
                i=f[:,0], j=f[:,1], k=f[:,2],
                opacity=0.6,
                flatshading=True,
                name="STL",
                lighting=dict(ambient=0.4, diffuse=0.6, specular=0.2),
                lightposition=dict(x=1, y=1, z=1),
                showscale=False,
            )
        ]
    )
    fig.update_layout(
        title=title,
        scene=dict(aspectmode="data"),
        margin=dict(l=0, r=0, t=40, b=0),
    )
    return fig

def plot_paths(polylines: List[np.ndarray], title="Sliced Paths (3D)") -> go.Figure:
    fig = go.Figure()
    for poly in polylines:
        fig.add_trace(
            go.Scatter3d(
                x=poly[:,0], y=poly[:,1], z=poly[:,2],
                mode="lines",
                line=dict(width=3),
                name="path"
            )
        )
    fig.update_layout(
        title=title,
        scene=dict(aspectmode="data"),
        margin=dict(l=0, r=0, t=40, b=0),
        showlegend=False,
    )
    return fig

# =========================
# Sidebar Parameters (same options, same defaults as your code)
# =========================
st.sidebar.header("⚙️ Parameters")
z_int        = st.sidebar.number_input("Z interval (mm)",  1.0, 1000.0, 15.0)
feed         = st.sidebar.number_input("Feedrate (F)",     1,    100000, 2000)
ref_x        = st.sidebar.number_input("Reference X",      value=0.0)
ref_y        = st.sidebar.number_input("Reference Y",      value=0.0)

st.sidebar.subheader("Extrusion options")
e_on         = st.sidebar.checkbox("Insert E values")
start_e_on   = st.sidebar.checkbox("Continuous Layer Printing", value=False, disabled=not e_on)
start_e_val  = st.sidebar.number_input("Start E value", value=0.1, disabled=not (e_on and start_e_on))
e0_on        = st.sidebar.checkbox("Add E0 at loop end", value=False, disabled=not e_on)

st.sidebar.subheader("Path processing")
trim_dist    = st.sidebar.number_input("Trim/Layer Width (mm)", 0.0, 1000.0, 50.0)
min_spacing  = st.sidebar.number_input("Minimum point spacing (mm)", 0.0, 1000.0, 3.0)
auto_start   = st.sidebar.checkbox("Start next layer near previous start")
m30_on       = st.sidebar.checkbox("Append M30 at end", value=False)

st.sidebar.markdown("---")

# =========================
# Layout: left controls / right viewers
# =========================
col_left, col_right = st.columns([0.48, 0.52])

with col_left:
    uploaded = st.file_uploader("📂 Upload STL", type=["stl"])

viewer_placeholder = col_right.empty()
path_viewer_placeholder = col_right.empty()
gcode_download_placeholder = col_left.empty()
slice_button_placeholder = col_left.empty()

mesh = None
if uploaded is not None:
    with tempfile.NamedTemporaryFile(delete=False, suffix=".stl") as tmp:
        tmp.write(uploaded.read())
        tmp_path = tmp.name

    try:
        mesh = trimesh.load_mesh(tmp_path)
        if not isinstance(mesh, trimesh.Trimesh):
            raise ValueError("STL must contain a single mesh")

        # Z만 아주 미세 확장 (원래 코드 그대로)
        scale_matrix = np.eye(4)
        scale_matrix[2, 2] = 1.0000001
        mesh.apply_transform(scale_matrix)

        st.success("STL loaded and Z-scale adjusted ✅")

        # === STL 3D Preview ===
        stl_fig = plot_trimesh(mesh, title="STL Preview")
        viewer_placeholder.plotly_chart(stl_fig, use_container_width=True)

    except Exception as e:
        st.error(f"Failed to load STL: {e}")
        st.stop()

    # =========================
    # Slice & Generate buttons
    # =========================
    do_slice = slice_button_placeholder.button("🔪 슬라이싱 (경로 미리보기 생성)")
    if do_slice and mesh is not None:
        with st.spinner("Slicing..."):
            # 미리보기용 경로 계산 (연산식은 generate와 동일 파이프라인)
            polylines = compute_slice_paths(
                mesh,
                z_int=z_int,
                ref_pt_user=(ref_x, ref_y),
                trim_dist=trim_dist,
                min_spacing=min_spacing,
                auto_start=auto_start
            )
        st.success(f"Slicing complete: {len(polylines)} path(s) ✅")
        path_fig = plot_paths(polylines, title="Sliced Paths (3D)")
        path_viewer_placeholder.plotly_chart(path_fig, use_container_width=True)

    # 기존 “Generate G-code” 유지 + 다운로드
    if col_left.button("🚀 Generate G-code"):
        with st.spinner("Processing..."):
            gcode_text = generate_gcode(
                mesh,
                z_int = z_int,
                feed = feed,
                ref_pt_user = (ref_x, ref_y),
                e_on = e_on,
                start_e_on = start_e_on,
                start_e_val = start_e_val,
                e0_on = e0_on,
                trim_dist = trim_dist,
                min_spacing = min_spacing,
                auto_start = auto_start,
                m30_on = m30_on
            )
        st.success("G-code generation finished 🎉")
        gcode_download_placeholder.download_button(
            "💾 G-code 저장 (Download)",
            gcode_text,
            file_name="output.gcode",
            mime="text/plain"
        )

st.markdown("---")
st.caption("© 2025 – STL → G-code Exporter (Streamlit Edition, 3D Viewer Enabled)")
