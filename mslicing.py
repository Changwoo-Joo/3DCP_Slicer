def generate_gcode(
    mesh,
    z_int=30.0,
    feed=2000,
    ref_pt_user=(0.0, 0.0),
    e_on=False,
    start_e_on=False,
    start_e_val=0.1,
    e0_on=False,
    trim_dist=30.0,
    min_spacing=3.0,
    auto_start=False,
    m30_on=False,
    travel_min_dist=0.05  # ★ 아주 짧은 이동은 생략(단위 mm)
):
    g = ["; *** Generated by 3DCP Slicer ***", "G21", "G90"]
    if e_on:
        g.append("M83")

    z_max = mesh.bounds[1, 2]
    z_values = list(np.arange(z_int, z_max + 0.001, z_int))
    if abs(z_max - z_values[-1]) > 1e-3:
        z_values.append(z_max)
    z_values.append(z_max + 0.01)

    prev_start_xy = None      # auto_start 기준점
    prev_end_xy = None        # ★ 마지막 출력점(세그먼트 끝점) 추적

    for z in z_values:
        sec = mesh.section(plane_origin=[0, 0, z], plane_normal=[0, 0, 1])
        if sec is None:
            continue
        try:
            slice2D, to3D = sec.to_2D()
        except Exception:
            continue

        segments = []
        for seg in slice2D.discrete:
            seg = np.array(seg)
            seg3d = (to3D @ np.hstack([seg, np.zeros((len(seg), 1)), np.ones((len(seg), 1))]).T).T[:, :3]
            segments.append(seg3d)
        if not segments:
            continue

        g.append(f"\n; ---------- Z = {z:.2f} mm ----------")

        # 레이어 시작 기준점
        if auto_start and prev_start_xy is not None:
            ref_pt_layer = prev_start_xy
        else:
            ref_pt_layer = np.array(ref_pt_user, dtype=float)

        for i_seg, seg3d in enumerate(segments):
            seg3d_no_dup = ensure_open_ring(seg3d)
            shifted, _   = shift_to_nearest_start(seg3d_no_dup, ref_point=ref_pt_layer)
            trimmed      = trim_closed_ring_tail(shifted, trim_dist)
            simplified   = simplify_segment(trimmed, min_spacing)

            # ★ 빈 세그먼트(점 < 2) 스킵 → 불필요한 이동 방지
            if simplified is None or len(simplified) < 2:
                continue

            # ★ 세그먼트 간 프리포지셔닝: G0 사용 + 아주 짧은 이동은 생략
            s = simplified[0]
            if i_seg > 0:
                if prev_end_xy is None or np.linalg.norm((s[:2] - prev_end_xy)) > float(travel_min_dist):
                    g.append(f"G0 X{s[0]:.3f} Y{s[1]:.3f} Z{z:.3f}")

            # 시작점 + 피드
            g.append(f"G01 F{feed}")
            if start_e_on:
                g.append(f"G01 X{s[0]:.3f} Y{s[1]:.3f} Z{z:.3f} E{start_e_val:.5f}")
            else:
                g.append(f"G01 X{s[0]:.3f} Y{s[1]:.3f} Z{z:.3f}")

            # 본 경로(압출/비압출) 출력
            for p1, p2 in zip(simplified[:-1], simplified[1:]):
                dist = np.linalg.norm(p2[:2] - p1[:2])
                if e_on:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f} E{dist * EXTRUSION_K:.5f}")
                else:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f}")

            if e0_on:
                g.append("G01 E0")

            # 다음 레이어 auto_start 기준 및 다음 이동 판단을 위해 마지막 점 갱신
            prev_start_xy = simplified[0][:2]   # auto_start용 (첫 시작점)
            prev_end_xy   = simplified[-1][:2]  # ★ 마지막 출력점(세그 끝점)

    g.append(f"G01 F{feed}")
    if m30_on:
        g.append("M30")
    return "\n".join(g)
