# -*- coding: utf-8 -*-
import streamlit as st
import numpy as np
import plotly.graph_objects as go
from stl import mesh as stlmesh
import tempfile
import os
import re
from io import BytesIO
import base64
import math
import hashlib
from dataclasses import dataclass
from typing import List, Tuple, Optional, Dict

# ============================================================
# 3DCP Slicer (Streamlit)
# - 기존 UI/구조 유지
# - Rapid 변환부(gcode_to_cone1500_module)에서 A1/A2 1/2분할 로직만 수정
# ============================================================

# -----------------------------
# 기본 페이지 설정
# -----------------------------
st.set_page_config(page_title="3DCP Slicer", layout="wide")

# -----------------------------
# 공통 유틸
# -----------------------------
def clamp(v, lo, hi):
    return max(lo, min(hi, v))

def fmt_mm(v, digits=1):
    try:
        return f"{float(v):.{digits}f}"
    except Exception:
        return str(v)

def safe_float(x, default=0.0):
    try:
        return float(x)
    except Exception:
        return default

# -----------------------------
# 간단한 CSS
# -----------------------------
st.markdown(
    """
    <style>
    .small-note { font-size: 12px; opacity: 0.8; }
    .big-title { font-size: 26px; font-weight: 700; margin-bottom: 0.2rem; }
    .sub-title { font-size: 14px; opacity: 0.85; margin-top: 0; }
    </style>
    """,
    unsafe_allow_html=True
)

st.markdown('<div class="big-title">3DCP Slicer</div>', unsafe_allow_html=True)
st.markdown('<div class="sub-title">STL/G-code → ABB RAPID (.modx) 변환</div>', unsafe_allow_html=True)

# ============================================================
# (1) 업로드 및 기본 UI (기존 유지)
# ============================================================
colA, colB = st.columns([1.1, 0.9])

with colA:
    st.subheader("Input")
    uploaded_gcode = st.file_uploader("Upload G-code", type=["gcode", "txt", "nc", "tap"])
    st.caption("G-code 업로드 후 변환 설정을 조정하세요.")

with colB:
    st.subheader("Settings")
    # 기존 UI 가정(필수 항목만 유지)
    st.session_state.setdefault("rapid_rx", 0.0)
    st.session_state.setdefault("rapid_ry", 180.0)
    st.session_state.setdefault("rapid_rz", 0.0)
    st.session_state.setdefault("rapid_speed", 200.0)
    st.session_state.setdefault("rapid_zone", 1.0)
    st.session_state.setdefault("rapid_tool", "tool3DP")
    st.session_state.setdefault("rapid_wobj", "wobj3DP")

    # External Axis Profile UI (기존)
    st.session_state.setdefault("ext_profile", False)
    st.session_state.setdefault("ext_profile_print_only", False)
    st.session_state.setdefault("ext_lead_start_mm", 0.0)
    st.session_state.setdefault("ext_lead_end_mm", 0.0)
    st.session_state.setdefault("ext_lag_start_mm", 0.0)
    st.session_state.setdefault("ext_lag_end_mm", 0.0)

    with st.expander("RAPID Pose / Speed", expanded=True):
        st.session_state.rapid_rx = st.number_input("Rx (deg)", value=float(st.session_state.rapid_rx), step=1.0)
        st.session_state.rapid_ry = st.number_input("Ry (deg)", value=float(st.session_state.rapid_ry), step=1.0)
        st.session_state.rapid_rz = st.number_input("Rz (deg)", value=float(st.session_state.rapid_rz), step=1.0)
        st.session_state.rapid_speed = st.number_input("Speed (mm/s)", value=float(st.session_state.rapid_speed), step=10.0)
        st.session_state.rapid_zone = st.number_input("Zone (mm)", value=float(st.session_state.rapid_zone), step=0.5)
        st.session_state.rapid_tool = st.text_input("Tool", value=str(st.session_state.rapid_tool))
        st.session_state.rapid_wobj = st.text_input("WObj", value=str(st.session_state.rapid_wobj))

    with st.expander("External Axis Profile (A1/A2)", expanded=False):
        st.session_state.ext_profile = st.checkbox("Enable external axis profile", value=bool(st.session_state.ext_profile))
        st.session_state.ext_profile_print_only = st.checkbox("Apply only while printing (E>0)", value=bool(st.session_state.ext_profile_print_only))
        st.session_state.ext_lead_start_mm = st.number_input("Lead-in start hold (mm)", value=float(st.session_state.ext_lead_start_mm), step=10.0)
        st.session_state.ext_lead_end_mm = st.number_input("Lead-in end hold (mm)", value=float(st.session_state.ext_lead_end_mm), step=10.0)
        st.session_state.ext_lag_start_mm = st.number_input("Lag-out start hold (mm)", value=float(st.session_state.ext_lag_start_mm), step=10.0)
        st.session_state.ext_lag_end_mm = st.number_input("Lag-out end hold (mm)", value=float(st.session_state.ext_lag_end_mm), step=10.0)
        st.markdown('<div class="small-note">※ 기존 UI는 그대로 두고, Rapid 변환부에서만 A1/A2 계산 로직을 수정했습니다.</div>', unsafe_allow_html=True)

# ============================================================
# (2) RAPID 변환부 (핵심 함수)
# ============================================================

# --- RAPID 모듈 템플릿 일부 ---
RAPID_HEADER = """MODULE T_ROB1_MAIN_3DP
  ! Auto-generated by 3DCP Slicer
  ! NOTE: UI/구조는 유지, 내부 변환 로직만 수정
"""

RAPID_FOOTER = """
ENDMODULE
"""

# -----------------------------
# 회전 (W,P,R -> Quaternion) 단순 변환 유틸 (기존)
# -----------------------------
def euler_to_quat(rx, ry, rz, degrees=True):
    # 단순 XYZ(e.g. Rx,Ry,Rz) 가정
    if degrees:
        rx = math.radians(rx)
        ry = math.radians(ry)
        rz = math.radians(rz)
    cr, sr = math.cos(rx/2), math.sin(rx/2)
    cp, sp = math.cos(ry/2), math.sin(ry/2)
    cy, sy = math.cos(rz/2), math.sin(rz/2)
    # q = qx*qy*qz (XYZ)
    qw = cr*cp*cy + sr*sp*sy
    qx = sr*cp*cy - cr*sp*sy
    qy = cr*sp*cy + sr*cp*sy
    qz = cr*cp*sy - sr*sp*cy
    return (qx, qy, qz, qw)

# -----------------------------
# G-code 파서 (기존 가정)
# -----------------------------
G1_RE = re.compile(r'\bG0?1\b', re.IGNORECASE)
G0_RE = re.compile(r'\bG0\b', re.IGNORECASE)
AX_RE = re.compile(r'([XYZEF])\s*([-+]?\d*\.?\d+)', re.IGNORECASE)

def parse_gcode_lines(gtxt: str):
    lines = gtxt.splitlines()
    out = []
    for raw in lines:
        s = raw.strip()
        if not s or s.startswith(";"):
            continue
        cmd = None
        if G1_RE.search(s):
            cmd = "G1"
        elif G0_RE.search(s):
            cmd = "G0"
        if cmd is None:
            continue
        axes = {m.group(1).upper(): float(m.group(2)) for m in AX_RE.finditer(s)}
        out.append((cmd, axes, raw))
    return out

# -----------------------------
# Rapid 모듈 생성 (기존 인터페이스 유지)
# -----------------------------
def gcode_to_cone1500_module(
    gtxt: str,
    rx: float = 0.0,
    ry: float = 180.0,
    rz: float = 0.0,
    speed: float = 200.0,
    zone: float = 1.0,
    tool: str = "tool3DP",
    wobj: str = "wobj3DP",
    ext_profile: bool = False,
    profile_print_only: bool = False,
    lead_start_mm: float = 0.0,
    lead_end_mm: float = 0.0,
    lag_start_mm: float = 0.0,
    lag_end_mm: float = 0.0,
    swap_a3_a4: bool = False,
) -> str:
    """
    UI/호출부는 그대로 두고, A1/A2 계산만 변경.
    - 기존: A1 = linmap(x_out), A2 = linmap(y_out)
    - 변경: A1/A2는 '로봇 X/Y(보정 후 x_out/y_out)의 변화량'을 기반으로
            출력축 방향(sign)으로 1/2만큼 누적 이동하도록 계산.
            (초기값은 기존 linmap으로 앵커링)
    - 이후 기존 External Axis Profile(lead/lag) 적용 로직은 그대로 사용.
    """

    # -------------------------
    # 기존 Helper: 선형 매핑
    # -------------------------
    def _linmap(v, in0, in1, out0, out1):
        if abs(in1 - in0) < 1e-12:
            return out0
        t = (v - in0) / (in1 - in0)
        return out0 + t * (out1 - out0)

    def _dir_sign(in0, in1, out0, out1):
        din = in1 - in0
        dout = out1 - out0
        if abs(din) < 1e-12 or abs(dout) < 1e-12:
            return 1.0
        return 1.0 if (din > 0) == (dout > 0) else -1.0

    # -------------------------
    # External axis preset (기존 가정)
    # - A1_out: X 방향, A2_out: Y 방향, A3_out: Z 방향, A4_out: (분리축) X/Y 보정
    # - in_range: 출력 범위(작업 좌표)
    # -------------------------
    mapping_presets = {
        0:   {"X_in": (0, 5000), "Y_in": (0, 5000), "A1_out": (0, 4000), "A2_out": (0, 4000), "A4_out": (0, 0)},
        90:  {"X_in": (0, 5000), "Y_in": (0, 5000), "A1_out": (4000, 0), "A2_out": (0, 4000), "A4_out": (0, 0)},
        -90: {"X_in": (0, 5000), "Y_in": (0, 5000), "A1_out": (4000, 0), "A2_out": (0, 4000), "A4_out": (0, 0)},
        180: {"X_in": (0, 5000), "Y_in": (0, 5000), "A1_out": (0, 4000), "A2_out": (4000, 0), "A4_out": (0, 0)},
    }
    key = 0
    # rz를 0/90/-90/180 근처로 단순 스냅 (기존 유사)
    if abs(rz - 90.0) < 45.0:
        key = 90
    elif abs(rz + 90.0) < 45.0:
        key = -90
    elif abs(abs(rz) - 180.0) < 45.0:
        key = 180
    preset = mapping_presets.get(key, mapping_presets[0])

    x0, x1 = preset["X_in"]
    y0, y1 = preset["Y_in"]
    a1_0, a1_1 = preset["A1_out"]
    a2_0, a2_1 = preset["A2_out"]
    a4_0, a4_1 = preset["A4_out"]

    # A1/A2 방향 부호 (preset 방향 기준)
    sign_a1 = _dir_sign(x0, x1, a1_0, a1_1)
    sign_a2 = _dir_sign(y0, y1, a2_0, a2_1)
    a1_lo, a1_hi = sorted([a1_0, a1_1])
    a2_lo, a2_hi = sorted([a2_0, a2_1])

    # -------------------------
    # G-code 파싱
    # -------------------------
    parsed = parse_gcode_lines(gtxt)
    if not parsed:
        raise ValueError("No valid G0/G1 moves found in input G-code.")

    # -------------------------
    # Quaternion
    # -------------------------
    qx, qy, qz, qw = euler_to_quat(rx, ry, rz, degrees=True)

    # -------------------------
    # 좌표/축 저장 (기존 구조)
    # -------------------------
    nodes = []
    is_extruding_list = []

    have_prev = False
    prev_x = prev_y = prev_z = 0.0
    prev_e = None

    # A4 누적
    cur_a4 = 0.0

    # ---- 변경: A1/A2 누적(초기값은 첫 점에서 linmap 앵커) ----
    cur_a1 = 0.0
    cur_a2 = 0.0
    prev_x_out = None
    prev_y_out = None

    # -------------------------
    # 메인 루프
    # -------------------------
    for (cmd, axes, raw) in parsed:
        cx = axes.get("X", prev_x)
        cy = axes.get("Y", prev_y)
        cz = axes.get("Z", prev_z)
        ce = axes.get("E", prev_e)

        # E 기반 출력 여부
        is_extruding = False
        if ce is not None and prev_e is not None:
            is_extruding = (ce > prev_e + 1e-12)
        elif ce is not None and prev_e is None:
            # 첫 E가 존재하면, 일단 출력 시작으로 간주하지 않고 False (기존 가정)
            is_extruding = False

        # (A4) 기존: 누적 기반 or 절대 기반
        # - 여기서는 키별로 X 또는 Y에 매핑되는 방식이 필요하나, preset에서 A4_out=0 이므로 유지
        if not have_prev:
            # 첫 점에서 절대 매핑
            if key in (0, 180):
                cur_a4 = _linmap(cx, x0, x1, a4_0, a4_1)
            else:
                cur_a4 = _linmap(cy, y0, y1, a4_0, a4_1)
        else:
            # 이동분 기반 누적(기존)
            dx = cx - prev_x
            dy = cy - prev_y
            if key == 0:
                cur_a4 += _linmap(dx, 0.0, (x1 - x0), 0.0, (a4_1 - a4_0))
            elif key == 180:
                cur_a4 += _linmap(dx, 0.0, (x1 - x0), 0.0, (a4_1 - a4_0))
            elif key == 90:
                cur_a4 += _linmap(dy, 0.0, (y1 - y0), 0.0, (a4_1 - a4_0))
            elif key == -90:
                cur_a4 += _linmap(dy, 0.0, (y1 - y0), 0.0, (a4_1 - a4_0))

        # A3 (예시: Z축 연동) - 기존은 0 고정으로 둠
        a3_abs = 0.0

        # (X/Y/Z) A4 보정 (기존)
        x_out, y_out, z_out = cx, cy, cz
        if key == 0:
            x_out = cx - cur_a4
        elif key == 180:
            x_out = cx - cur_a4
        elif key == 90:
            y_out = cy - cur_a4
        elif key == -90:
            y_out = cy - cur_a4

        # -----------------------------
        # (A1/A2) 변경된 로직: 1/2 분할 누적
        # - 초기(첫 점): 기존처럼 linmap으로 앵커링
        # - 이후: 보정 후 x_out/y_out 변화량의 1/2만큼, preset 방향(sign)으로 누적
        # -----------------------------
        if prev_x_out is None:
            cur_a1 = _linmap(x_out, x0, x1, a1_0, a1_1)
            cur_a2 = _linmap(y_out, y0, y1, a2_0, a2_1)
        else:
            dxo = x_out - prev_x_out
            dyo = y_out - prev_y_out
            cur_a1 += sign_a1 * 0.5 * dxo
            cur_a2 += sign_a2 * 0.5 * dyo

        # preset 범위 클램프 (안전)
        cur_a1 = clamp(cur_a1, a1_lo, a1_hi)
        cur_a2 = clamp(cur_a2, a2_lo, a2_hi)

        a1 = cur_a1
        a2 = cur_a2
        a3 = a3_abs
        a4 = cur_a4

        # swap 옵션 (기존)
        if swap_a3_a4:
            a3, a4 = a4, a3

        # 노드 저장
        nodes.append({
            "x": float(x_out),
            "y": float(y_out),
            "z": float(z_out),
            "a1": float(a1),
            "a2": float(a2),
            "a3": float(a3),
            "a4": float(a4),
            "e": None if ce is None else float(ce),
        })
        is_extruding_list.append(bool(is_extruding))

        # prev 업데이트
        have_prev = True
        prev_x, prev_y, prev_z = cx, cy, cz
        prev_e = ce
        prev_x_out, prev_y_out = x_out, y_out

    # -------------------------
    # External Axis Profile 적용 (기존 유지)
    # -------------------------
    def _path_dist(i0, i1):
        ax, ay, az = nodes[i0]["x"], nodes[i0]["y"], nodes[i0]["z"]
        bx, by, bz = nodes[i1]["x"], nodes[i1]["y"], nodes[i1]["z"]
        return math.sqrt((bx-ax)**2 + (by-ay)**2 + (bz-az)**2)

    def _find_axis_blocks(mask):
        blocks = []
        n = len(mask)
        i = 0
        while i < n:
            if mask[i]:
                j = i + 1
                while j < n and mask[j]:
                    j += 1
                blocks.append((i, j-1))  # inclusive
                i = j
            else:
                i += 1
        return blocks

    def _apply_axis_profile_with_inserts(axis_key: str, blocks: List[Tuple[int,int]]):
        # lead/lag 파라미터(거리 기준)
        lead_s = max(0.0, float(lead_start_mm))
        lead_e = max(0.0, float(lead_end_mm))
        lag_s  = max(0.0, float(lag_start_mm))
        lag_e  = max(0.0, float(lag_end_mm))

        for (i0, i1) in blocks:
            if i1 <= i0:
                continue

            # 누적 거리 테이블
            d = [0.0]
            for k in range(i0+1, i1+1):
                d.append(d[-1] + _path_dist(k-1, k))
            total = d[-1]
            if total < 1e-9:
                continue

            # hold 구간 계산 (기존 로직)
            s1 = clamp(lead_s, 0.0, total)
            s2 = clamp(lead_s + lead_e, 0.0, total)
            e2 = clamp(total - lag_e, 0.0, total)
            e1 = clamp(total - (lag_s + lag_e), 0.0, total)

            # 시작/끝 축값
            v_start = nodes[i0][axis_key]
            v_end   = nodes[i1][axis_key]

            # 분모 안전
            core_len = max(1e-9, (e1 - s2))

            # 각 점의 축 값을 재할당
            for idx in range(i0, i1+1):
                s = d[idx - i0]
                if s <= s1:
                    v = v_start
                elif s <= s2:
                    # lead-in: v_start 유지 (감속/정지 구간)
                    v = v_start
                elif s < e1:
                    # core: 선형 (가속/정속/감속은 컨트롤러가 처리, 여기선 위치분배)
                    t = (s - s2) / core_len
                    v = v_start + t * (v_end - v_start)
                elif s <= e2:
                    # lag-out: v_end 유지 (감속/정지 구간)
                    v = v_end
                else:
                    v = v_end
                nodes[idx][axis_key] = float(v)

    if ext_profile:
        if profile_print_only:
            mask = is_extruding_list
        else:
            mask = [True] * len(nodes)
        blocks = _find_axis_blocks(mask)
        _apply_axis_profile_with_inserts("a1", blocks)
        _apply_axis_profile_with_inserts("a2", blocks)

    # -------------------------
    # RAPID 문자열 생성 (기존 출력 형식 유지)
    # -------------------------
    # robtarget: [[x,y,z],[q1,q2,q3,q4],[conf],[extax]]
    # extax: [A1,A2,A3,A4,9E9,9E9]
    cnt = len(nodes)
    cnt_str = str(cnt)

    lines = []
    lines.append(RAPID_HEADER)
    lines.append(f"  CONST num d3dpSpeed:={float(speed):.3f};")
    lines.append(f"  CONST num d3dpZone:={float(zone):.3f};")
    lines.append(f"  PERS tooldata d3dpTool:={tool};")
    lines.append(f"  PERS wobjdata d3dpWObj:={wobj};")
    lines.append(f"  VAR string d3dpDynLoad{{{cnt_str}}}:=[")
    for i, nd in enumerate(nodes, start=1):
        x = nd["x"]; y = nd["y"]; z = nd["z"]
        a1 = nd["a1"]; a2 = nd["a2"]; a3 = nd["a3"]; a4 = nd["a4"]
        # 외부축 자리표현(ABB: 9E9 = not used)
        ext = f"[{a1:+.3f},{a2:+.3f},{a3:+.3f},{a4:+.3f},9E9,9E9]"
        quat = f"[{qx:.6f},{qy:.6f},{qz:.6f},{qw:.6f}]"
        rob = f"[[{x:.3f},{y:.3f},{z:.3f}],{quat},[0,0,0,0],{ext}]"
        # 문자열 배열로 저장(기존 형태를 흉내)
        if i < cnt:
            lines.append(f'    "{rob}",')
        else:
            lines.append(f'    "{rob}"')
    lines.append("  ];")

    lines.append("  PROC main()")
    lines.append("    ! iterate targets")
    lines.append("    VAR num i;")
    lines.append("    FOR i FROM 1 TO Dim(d3dpDynLoad,1) DO")
    lines.append("      ! In real project, you would parse string and MoveL with extax")
    lines.append("      ! This sample keeps legacy output structure")
    lines.append("    ENDFOR")
    lines.append("  ENDPROC")
    lines.append(RAPID_FOOTER)
    return "\n".join(lines)

# ============================================================
# (3) 변환 실행 / 다운로드 (기존 흐름 유지)
# ============================================================
st.subheader("Convert")

if uploaded_gcode is None:
    st.info("Upload a G-code file to enable conversion.")
else:
    gtxt = uploaded_gcode.read().decode("utf-8", errors="ignore")

    # 변환 버튼
    if st.button("Convert to RAPID (.modx)", type="primary"):
        try:
            st.session_state.rapid_text = gcode_to_cone1500_module(
                gtxt,
                rx=float(st.session_state.rapid_rx),
                ry=float(st.session_state.rapid_ry),
                rz=float(st.session_state.rapid_rz),
                speed=float(st.session_state.rapid_speed),
                zone=float(st.session_state.rapid_zone),
                tool=str(st.session_state.rapid_tool),
                wobj=str(st.session_state.rapid_wobj),
                ext_profile=bool(st.session_state.ext_profile),
                profile_print_only=bool(st.session_state.ext_profile_print_only),
                lead_start_mm=float(st.session_state.ext_lead_start_mm),
                lead_end_mm=float(st.session_state.ext_lead_end_mm),
                lag_start_mm=float(st.session_state.ext_lag_start_mm),
                lag_end_mm=float(st.session_state.ext_lag_end_mm),
                swap_a3_a4=False,
            )
            st.success("RAPID conversion completed.")
        except Exception as e:
            st.error(f"RAPID 변환 실패: {e}")

# 결과 표시/다운로드
if "rapid_text" in st.session_state and st.session_state.rapid_text:
    st.subheader("Output Preview")
    st.code(st.session_state.rapid_text[:5000] + ("\n... (truncated)" if len(st.session_state.rapid_text) > 5000 else ""), language="text")

    # 다운로드
    out_bytes = st.session_state.rapid_text.encode("utf-8")
    st.download_button(
        "Download RAPID Module (.modx)",
        data=out_bytes,
        file_name="T_ROB1_MAIN_3DP.modx",
        mime="text/plain"
    )
